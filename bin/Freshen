#!/usr/bin/python
# Copyright (C) 2008 Michael Homer <=mwh>
# Portions copyright (C) 2004-2007 Andre Detsch <detsch at gobolinux.org>
# Released under the GNU GPL.

import string, os, os.path, sys, cPickle
import time
sys.path = [os.path.abspath('.')+'/lib/python2.3'] + sys.path

from GetAvailable      import GetAvailable, getGoboVariable
from GuessLatest       import GuessLatest
from GetInstalled      import KeyInsensitiveDict
from CheckDependencies import *
from PythonUtils       import *
from TTYUtils          import *


def getTypeAbbr(type):
	return {
		'recipe': Screen.colours['green']+'R'+Screen.colours['normal'],
		'official_package': Screen.colours['brown']+'P'+Screen.colours['normal'],
		'installed': 'I',
		None: '?'
	}[type]
def puts(s):
	sys.stdout.write(s+'\n')

def showUpdates():
	i=0
	System.installedPrograms()
	systemUpgrades = {'Scripts': None, 'Compile': None, 'Freshen': None}
	typeCount = {'recipe': 0, 'official_package': 0, '_binary_recipe': 0 ,'total': 0}
	for program,version,revision,ptype,url,intBy in System.updates():
		if i == 0: # Only output heading the first time, if there are any.
			puts("[  ] Program%sInstalled"%(' '*(Screen.width-21)))
		i+=1
		typeCount[ptype] += 1
		typeCount['total'] += 1
		ver = Join_Version_Revision(version, revision)
		if program in systemUpgrades: systemUpgrades[program] = ptype
		insVer = "None"
		pcol = Screen.colours['darkgreybg']
		insVer = str(System.latestInstalled(program))
		if insVer != 'None':
			pcol = ''
		if pcol == '':
			if i%2==0:
				pcol=Screen.colours['blue']
			else:
				pcol=Screen.colours['cyan']
		tabbr = getTypeAbbr(ptype)
		if version.endswith('_bin') or program.endswith('-Bin'):
			tabbr = Screen.colours['red']+'B'+Screen.colours['normal']+tabbr
			typeCount['_binary_recipe'] += 1
		else: tabbr = ' ' + tabbr
		ibstring = insVer == 'None' and '(' + intBy + ')' or ''
		ncol = Screen.colours['normal']
		pad = " " * (Screen.width-len(program)-len(ver)-len(insVer)-len(ibstring)-7)
		out = "[%s] %s%s %s %s%s%s%s"%(tabbr, pcol, program, ver, ibstring, pad, insVer, ncol)
		puts(out)
	puts("%(recipe)i recipes, %(_binary_recipe)i binary recipes, %(official_package)i packages, %(total)i total"%typeCount)
	for prog in ('Scripts', 'Compile', 'Freshen'):
		if systemUpgrades[prog]:
			cmd = systemUpgrades[prog] == 'recipe' and 'Compile' or 'InstallPackage'
			Log_Error("An upgrade to %s is available. It is strongly recommended that you upgrade immediately with `%s %s`."%(prog, cmd, prog), 'Freshen')

# Parse the value of a shell variable out of a file (recipe), performing variable substitutions.
def parse_var(s, definitions=None):
	from string import Template
	if not hasattr(shellparse, 'definitions'):
		shellparse.definitions = {
			'goboPrograms': getGoboVariable('goboPrograms'),
			'goboShared':   getGoboVariable('goboShared'),
			'goboSettings': getGoboVariable('goboSettings'),
			'goboLinks':    getGoboVariable('goboLinks'),
		}
	if not definitions:
		definitions = {}
	definitions.update(shellparse.definitions)
	for k in definitions:
		t = Template(definitions[k])
		t.safe_substitute(definitions)
	t = Template(s.split('=', 2)[1:-1])
	return t.safe_substitute(definitions)
	
# TODO: Handle failed installations
def installUpdates():
	i=0
	postMessages = []
	programs = set()
	for program,version,revision,ptype,url,intBy in System.updates():
		i+=1
		programs.add(program)
		ver = Join_Version_Revision(version, revision)
		Log_Normal("Installing update %i/%i: %s %s..."%(i, len(ulist), program, ver), 'Freshen')
		if ptype == 'recipe':
			os.system("Compile -G -U -D -b %s"%(url))
			rec = os.popen('GetRecipe %s %s'%(program, ver)).readline().strip()+'/Recipe'
			if os.path.exists(rec):
				f = open(rec, 'r')
				for x in f:
					if x.startswith('post_install_message='):
						postMessages.append((program, parse_var(x, {'target': '$goboPrograms/%s/%s' % (program,version)})))
						break
				f.close()
		elif ptype == 'official_package':
			os.system("InstallPackage -k -U -s keep -b -D -u keep %s"%(url))
		else:
			Log_Error("Unknown action '%s'!"%(ptype))
			exit()
	for program,version,revision,ptype,url in ulist:
		if os.system("UpdateSettings -c" + program):
			os.system("UpdateSettings -a "+program)
	if postMessages:
		Log_Normal("Some of the installed programs requested post-install messages be displayed:")
		for p,v in postMessages:
			puts("%s: %s"%(p, v))
	System.clearCache()

def showHelp():
	puts("""
Checks for updated GoboLinux recipes and packages.

Usage: Freshen [<opts>] [<list>]

Options:
   --exclude, -x <xlist>
      Exclude <xlist> from updating. Does not exclude other programs depending
      on <xlist>.
   --force-cache, -c
      Force using cached updates data, rather than recalculating them.
   --no-cache, -C
      Force regenerating updates data, rather than reading from cache.
   --thorough
      Include deep updates to revisions and up-to-date dependencies.
   -U
      Install updates.

Notes:
Run with no arguments, Freshen outputs a list of updates in the form:
[%(red)sB%(green)sR%(normal)s] Foo 2.0                                                                 1.0
The mnemonics mean:
 %(green)sR%(normal)s Recipe will be used                    %(brown)sNew program%(normal)s
 %(brown)sP%(normal)s Package will be used                   Other colours are for readability only
 %(red)sB%(normal)s Binary recipe

If <list> is provided, Freshen examines only the programs in it and their dependencies. If <list> is not provided, Freshen will examine all installed programs.

Examples:
   Freshen -x LibFoo LibBar -U Baz Quux
"""%Screen.colours)

class FreshenArgParser:
	def __init__(self):
		self.fetched = False
	def fetch(self):
		if self.fetched:
			return
		self.fetched = True
		self.skipSet = set()
		self.eset = set()
		self.mode = 'updating'
		self.noCache = False
		self.forceCache = False
		self.action = showUpdates
		self.limit = None
		catching = self.eset
		singleCatch = ''
		for li in sys.argv[1:]:
			if li=='-x' or li=='--exclude':
				catching = self.skipSet
			else:
				reset = True # Reset catching to eset if we hit a non-list option
				if li=='--thorough':
					self.mode = 'all'
				elif li=='--no-cache' or li=='-C':
					self.noCache = True
				elif li=='--force-cache' or li=='-c':
					self.forceCache = True
				elif li=='--limit' or li=='-l':
					singleCatch = 'limit'
				elif li=='-U':
					self.action = installUpdates
				elif li=='--help':
					self.action=showHelp
				elif li=='--no-colour':
					for c in Screen.colours:
						Screen.colours[c] = ''
				elif li=='--':
					catching = eset
				elif singleCatch:
					self.__dict__[singleCatch] = li
					singleCatch = ''
				elif li[0:2]=='--':
					Log_Error("Invalid argument "+li, 'Freshen')
					exit()
				else:
					catching.add(li)
					reset = False
				if reset: catching = self.eset
		self.progString = ', '.join(self.eset)
		self.eset = frozenset(self.eset)
		self.skipSet = frozenset(self.skipSet)
		self.cacheDataID = hash(self.eset)
	def __getattr__(self, name):
		self.fetch()
		if 'examineSet' == name:
			if self.eset:
				return self.eset
			else:
				self.eset = frozenset(set(System.installedPrograms().keys()))
				self.cacheDataID = hash(self.eset)
				self.progString = 'all'
				return self.eset
		return self.__dict__[name]

class System:
	args = FreshenArgParser()
	ipcache = {}
	vcache = {}
	@classmethod
	def installedPrograms(self):
		if self.ipcache:
			return self.ipcache
		else:
			global global_available_packages_cache
			if not global_available_packages_cache: self.fetchAvailables()
			installed = global_available_packages_cache['installed']['programs']
			self.ipcache = KeyInsensitiveDict((prog, [v+'-'+r for v in installed[prog] for r in installed[prog][v]]) for prog in installed)
			return self.ipcache
			
	@classmethod
	def latestInstalled(self, p):
		if not self.vcache:
			self.vcache = KeyInsensitiveDict()
		if p in self.vcache:
			return self.vcache[p]
		else:
			if not self.ipcache: self.installedPrograms()
			if p in self.ipcache:
				self.vcache[p] = GuessLatest(self.ipcache[p])
			else:
				self.vcache[p] = None
			return self.vcache[p]
	
	@classmethod
	def updates(self):
		types = ['official_package', 'recipe']
		eset,mode,skipSet = System.args.examineSet,System.args.mode,System.args.skipSet
		i = yc = 0
		if System.args.limit: limit = int(System.args.limit)
		else: limit = None
		# Load from cache, and yield any programs in there up to the limit
		plist,considered = self.loadCache()
		pb = ProgressBar(len(eset), limit)
		for s in plist:
			if yc == limit: return # Satisfied request from cache, so terminate.
			if s[0] not in skipSet:
				yc+=1
				pb.inc2()
				yield s
		for p in eset:
			i+=1
			pb.inc()
			if p in considered: continue
			if limit and pb.value2 >= limit:
				self.saveCache(plist, considered)
				raise StopIteration
			# Process actual results from here
			deps,sols = CheckDependencies(p, acceptable_types=types, mode=mode, recursive=True)
			for s in [s for s in sols if s[0] not in considered]:
				considered.add(s[0])
				if s[3] != 'installed' and s[3] is not None:
					ver = Join_Version_Revision(s[1], s[2])
					insVer = self.latestInstalled(s[0])
					if not insVer or (insVer != ver and GuessLatest([ver, insVer]) == ver):
						s+=(p,)
						plist.append(s)
						# Only yield when under the limit, but continue the loop for caching's sake.
						if s[0] not in skipSet and (not limit or yc < limit):
							yc+=1
							if limit and yc>=limit: pb.clear()
							yield s
							pb.inc2()
		self.saveCache(plist, considered)
		pb.clear()
	
	@classmethod
	def cacheFile(self):
		cacheDir = os.environ.get('HOME') + '/.Settings/freshen_cache'
		if not os.path.exists(cacheDir):
			os.makedirs(cacheDir)
		return "%s/%s-%u"%(cacheDir, System.args.mode, System.args.cacheDataID)
		
	@classmethod
	def saveCache(self, plist, considered):
		f = open(self.cacheFile(), 'w')
		cPickle.dump(plist, f, protocol = cPickle.HIGHEST_PROTOCOL)
		cPickle.dump(considered, f, protocol = cPickle.HIGHEST_PROTOCOL)
		f.close()
		directory = os.environ.get('HOME') + '/.Settings/freshen_cache/'
		for f in os.listdir(directory):
			if time.time()-os.path.getmtime(directory+'/'+f)>1800:
				os.unlink(directory+'/'+f)
		
	@classmethod
	def loadCache(self):
		cacheFile = self.cacheFile()
		if System.args.forceCache or not System.args.noCache and os.path.exists(cacheFile) and os.path.exists(cacheFile) and time.time()-os.path.getmtime(cacheFile)<1800:
			Log_Normal("Loading updates list from cache... (use -C to disable)", 'Freshen')
			f = open(cacheFile, 'r')
			progList = cPickle.load(f)
			considered = cPickle.load(f)
			f.close()
			return (progList, considered)
		return ([], set())
	
	@classmethod
	def fetchAvailables(self):
		global global_available_packages_cache
		cacheFile = os.environ.get('HOME') + '/.Settings/freshen_cache/availables.cache'
		if global_available_packages_cache: return
		elif not System.args.noCache and os.path.exists(cacheFile) and (System.args.forceCache or time.time()-os.path.getmtime(cacheFile)<1800):
			f = open(cacheFile, 'r')
			global_available_packages_cache = cPickle.load(f)
			f.close()
		else:
			consoleProgressHook.endString = '\015'
			global_available_packages_cache = 	GetAvailable(types=['installed','local_package','official_package', 'recipe', 'contrib_package', 'tracked'], hook=consoleProgressHook)
			f = open(cacheFile, 'w')
			cPickle.dump(global_available_packages_cache, f, protocol = cPickle.HIGHEST_PROTOCOL)
			f.close()
	
	@classmethod
	def clearCache(self):
		cacheFile = System.cacheFile()
		for cacheFile in (System.cacheFile(), os.environ.get('HOME')+'/.Settings/freshen_cache/availables.cache'):
			if os.path.exists(cacheFile):
				os.unlink(cacheFile)

try:
	# Execute the defined action
	System.args.action()
except KeyboardInterrupt:
	pass
finally:
	sys.stderr.write("\033]2;\007");
