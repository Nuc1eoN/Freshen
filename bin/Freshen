#!/usr/bin/env python
# Freshen - finds and installs updates for GoboLinux systems.
# Copyright (C) 2007-2008 Michael Homer <=mwh>
# Distribution terms shown by Freshen --version.

import string, os, os.path, sys, pickle, time, functools

from GetAvailable      import GetAvailable
from GuessLatest       import GuessLatest
from CheckDependencies import *
from PythonUtils       import *
from TTYUtils          import *

import Freshen
import FreshenArgParser

def getTypeAbbr(type):
	return {
		'recipe': Screen.colours['green']+'R'+Screen.colours['normal'],
		'official_package': Screen.colours['brown']+'P'+Screen.colours['normal'],
		'installed': 'I',
		None: '?'
	}[type]
def puts(string):
	sys.stdout.write(string+'\n')

class FreshenUI(object):
	def __init__(self):
		interfaceCallbacks = dict()
		interfaceCallbacks['log_normal'] = self.log
		interfaceCallbacks['log_error'] = self.error
		interfaceCallbacks['loading_updates_from_cache'] = functools.partial(self.log, "Loading updates list from cache... (use -C to disable)")
		
		self.args = FreshenArgParser.FreshenArgParser(self)
		self.freshen = Freshen.Freshen(mode=self.args.mode, examineSet=self.args.examineSet, limit=self.args.limit, skipSet=self.args.skipSet, noCache=self.args.noCache, forceCache=self.args.forceCache, interfaceCallbacks=interfaceCallbacks)

	def error(self, message):
		Log_Error(message, 'Freshen')
	
	def log(self, message):
		Log_Normal(message, 'Freshen')

	def showUpdates(self):
		systemUpgrades = {'Scripts': None, 'Compile': None, 'Freshen': None}
		typeCount = {'recipe': 0, 'official_package': 0, '_binary_recipe': 0 ,'total': 0}
		pb = ProgressBar(len(self.freshen.examineSet), self.freshen.limit)
		for program,version,revision,type,url,intBy,enabledFlags,disabledFlags in self.freshen.updates(progressMeter=pb):
			# Only output heading the first time, if there are any.
			if typeCount['total']==0:
				puts("[  ] Program%sInstalled"%(' '*(Screen.width-21)))
			# Keep track of how many of each type and in total there are
			typeCount[type] += 1
			typeCount['total'] += 1
			
			ver = Join_Version_Revision(version, revision)
			
			# Remember if there are updates to system tools
			if program in systemUpgrades: systemUpgrades[program] = type
			
			# Initialise default values (uninstalled program)
			insVer = "None"
			pcol = Screen.colours['darkgreybg']
			
			insVer = str(self.freshen.latestInstalled(program))
			if insVer != 'None':
				pcol = ''
			if pcol == '':
				# Alternate colouring by row for easier reading
				if typeCount['total']%2==0:
					pcol=Screen.colours['blue']
				else:
					pcol=Screen.colours['cyan']
			
			typeAbbr = getTypeAbbr(type)
			
			# Flag binary recipes
			if version.endswith('_bin') or program.endswith('-Bin'):
				typeAbbr = Screen.colours['red']+'B'+Screen.colours['normal']+typeAbbr
				typeCount['_binary_recipe'] += 1
			else: typeAbbr = ' ' + typeAbbr
			
			# Display which program has this as a dependency if it isn't already installed
			introducedByString = insVer == 'None' and '(' + intBy + ')' or ''
			
			normalColour = Screen.colours['normal']
			
			# Perform output: flags are wrapped vertically when they don't fit on one line
			# The physical length of output must be tracked, which is different to the
			# string length because of colours
			maxlen = Screen.width - 10
			out = "[%s] %s%s %s %s " % (typeAbbr, pcol, program, ver, introducedByString)
			# outlen will be updated, minlen is used to pad wrapped text to line up
			outlen = len(program) + len(ver) + len(introducedByString) + 8
			minlen = outlen
			# Whether the installed version has been output or not
			insverout = False
			for flag in enabledFlags:
				# Do we need to wrap yet?
				if outlen + len(flag) + 2 < maxlen:
					outlen += len(flag) + 2
					out += Screen.colours['green'] + '+' + flag + ' '
				else:
					# If the current version hasn't been output (i.e. this is the first
					# line), tack it onto the end with the right padding to force it
					# against the margin.
					if not insverout:
						insverout = True
						out += pcol + ' '*(Screen.width-outlen-len(insVer)) + insVer
					puts(out)
					# Initialise the padding for the next line to vertically line up with
					# the first flag.
					out = ' ' * minlen
					outlen = len(out)
			# Now the same thing for disabled flags
			for flag in disabledFlags:
				if outlen + len(flag) + 2 < maxlen:
					outlen += len(flag) + 2
					out += Screen.colours['red'] + '+' + flag + ' '
				else:
					if not insverout:
						insverout = True
						out += pcol + ' '*(Screen.width-outlen-len(insVer)) + insVer
					puts(out)
					out = ' ' * minlen
					outlen = len(out)
			
			out += pcol
			# It's possible that the version hasn't been output yet; if not, do it.
			if not insverout:
				print outlen
				print len(insVer)
				print (Screen.width-outlen-len(insVer))
				insverout = True
				out += ' '*(Screen.width-outlen-len(insVer)) + insVer
			puts(out)
		puts("%(recipe)i recipes, %(_binary_recipe)i binary recipes, %(official_package)i packages, %(total)i total"%typeCount)
		for prog in ('Scripts', 'Compile', 'Freshen'):
			if systemUpgrades[prog]:
				cmd = systemUpgrades[prog] == 'recipe' and 'Compile' or 'InstallPackage'
				Log_Error("An upgrade to %s is available. It is strongly recommended that you upgrade immediately with `%s %s`."%(prog, cmd, prog), 'Freshen')
	
	# Parse the value of a shell variable out of a file (recipe), performing variable substitutions.
	def parse_var(string, variableDefinitions=None):
		from string import Template
		if not hasattr(parse_var, 'definitions'):
			parse_var.definitions = {
				'goboPrograms': getGoboVariable('goboPrograms'),
				'goboShared':   getGoboVariable('goboShared'),
				'goboSettings': getGoboVariable('goboSettings'),
				'goboLinks':    getGoboVariable('goboLinks'),
			}
		if not variableDefinitions:
			variableDefinitions = {}
		variableDefinitions.update(parse_var.variableDefinitions)
		for variable in variableDefinitions:
			t = Template(variableDefinitions[variable])
			variableDefinitions[variable] = t.safe_substitute(variableDefinitions)
		t = Template(string.split('=', 2)[1])
		return t.safe_substitute(variableDefinitions)
	
	# TODO: Handle failed installations
	def installUpdates(self):
		i=0
		postMessages = []
		programs = set()
		for program,version,revision,type,url,intBy,enabledFlags,disabledFlags in self.freshen.updates():
			i+=1
			programs.add(program)
			ver = Join_Version_Revision(version, revision)
			Log_Normal("Installing update %i: %s %s..."%(i, program, ver), 'Freshen')
			if type == 'recipe':
				os.system("Compile -G -U -D -b %s"%(url))
				rec = os.popen('GetRecipe %s %s'%(program, ver)).readline().strip()+'/Recipe'
				if os.path.exists(rec):
					file = open(rec, 'r')
					for line in file:
						if line.startswith('post_install_message='):
							postMessages.append((program, parse_var(line, {'target': '$goboPrograms/%s/%s' % (program,version)})))
							break
					file.close()
			elif type == 'official_package':
				os.system("InstallPackage -k -U -s keep -b -D -u keep %s"%(url))
			else:
				Log_Error("Unknown action '%s'!"%(type))
				exit()
		for program,version,revision,type,url,intBy in ulist:
			if os.system("UpdateSettings -c" + program):
				os.system("UpdateSettings -a "+program)
		if postMessages:
			Log_Normal("Some of the installed programs requested post-install messages be displayed:")
			for program,message in postMessages:
				puts("%s: %s"%(program, message))
		self.freshen.clearCache()
	
	def showVersion(self):
		puts("""
	Freshen %(major)i.%(minor)i.%(revision)i%(prerelease)s
	(C) 2007-2008 Michael Homer <=mwh>
	
	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.
	
	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.
	
	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.
	"""%(self.freshen.version))
	
	def showHelp(self):
		puts("""
	Checks for updated GoboLinux recipes and packages.
	
	Usage: Freshen [<opts>] [<list>]
	
	Options:
	--exclude, -x <xlist>
		Exclude <xlist> from updating. Does not exclude other programs depending
		on <xlist>.
	--install
		Install <list> without upgrading any dependencies.
	--force-cache, -c
		Force using cached updates data, rather than recalculating them.
	--no-cache, -C
		Force regenerating updates data, rather than reading from cache.
	--shallow, -s
		Only include <list> and necessary dependencies.
	--thorough
		Include deep updates to revisions and up-to-date dependencies.
	-U
		Install updates.
	--version
		Display version and copyright information.
	Notes:
	Run with no arguments, Freshen outputs a list of updates in the form:
	[%(red)sB%(green)sR%(normal)s] Foo 2.0                                                                 1.0
	The mnemonics mean:
	%(green)sR%(normal)s Recipe will be used                    %(brown)sNew program%(normal)s
	%(brown)sP%(normal)s Package will be used                   Other colours are for readability only
	%(red)sB%(normal)s Binary recipe
	
	If <list> is provided, Freshen examines only the programs in it and their dependencies. If <list> is not provided, Freshen will examine all installed programs.
	
	Examples:
	Freshen -x LibFoo LibBar -U Baz Quux
	"""%Screen.colours)

ui = FreshenUI()

try:
	# Execute the defined action
	ui.args.action()
except KeyboardInterrupt:
	pass
finally: # Clear title on exit
	sys.stderr.write("\033]2;\007");
exit(0)
