#!/usr/bin/python
# Copyright (C) 2008 Michael Homer <=mwh>
# Portions copyright (C) 2004-2007 Andre Detsch <detsch at gobolinux.org>
# Released under the GNU GPL.

import string, os, os.path, sys, cPickle

from GetAvailable      import GetAvailable, getGoboVariable
from GuessLatest       import GuessLatest
from GuessProgramCase  import GuessProgramCase
from GetInstalled      import KeyInsensitiveDict
from GetInstalled      import GetInstalled
from CheckDependencies import *

# For debugging output
def dbprint(s):
	if False:
		sys.stderr.write(s+"\n")

def getTypeAbbr(type):
	return {
		'recipe': 'R',
		'official_package': 'P',
		'installed': 'I',
		None: '?'
	}[type]

# Borrowed from Manager and adapted a little. Could be more concise, since
# I only want the installed < recipe,official_package case.
def applyFilter(availables, filter_rule, report_missing = False) :
	p1 = filter_rule[0][:]
	op = filter_rule[1]
	p2 = filter_rule[2][:]
	
	toReturn = []
	
	leftPrograms = []
	leftProgramsLower = []
	
	latestType = None
	latestURL = None

	for t in p1 :
		for p in availables[t]['programs'].keys() :
			if p.lower() not in leftProgramsLower :
				leftProgramsLower.append(p.lower())
				leftPrograms.append(p)
	 
	rightPrograms = []
	rightProgramsLower = []
	for t in p2 :
		for p in availables[t]['programs'].keys() :
			if p.lower() not in rightProgramsLower :
				rightProgramsLower.append(p.lower())
				rightPrograms.append(p)
	for p in leftPrograms :
		latestType = None
		latestURL = None
		if p.lower() in rightProgramsLower :
			leftLatestVR = '0'
			for t in p1 :
				try :
					leftLatestV = GuessLatest(availables[t]['programs'][p].keys())
					prevLLVR = leftLatestVR
					revision = GuessLatest(availables[t]['programs'][p][leftLatestV].keys())
					leftLatestVR = Join_Version_Revision(leftLatestV, revision)
					if leftLatestVR != prevLLVR:
						latestType = t
						latestURL = availables[t]['programs'][p][leftLatestV][revision][0]
				except :
					pass
			
			rightLatestVR = '0'
			for t in p2 :
				try :
					rightLatestV = GuessLatest(availables[t]['programs'][p].keys() + ['0'])
					prevRLVR = rightLatestVR
					revision = GuessLatest(availables[t]['programs'][p][rightLatestV].keys())
					rightLatestVR = Join_Version_Revision(rightLatestV, revision)
					if rightLatestVR != prevRLVR:
						latestType = t
						latestURL = availables[t]['programs'][p][rightLatestV][revision][0]
				except :
					pass
			
			latestVR = GuessLatest([leftLatestVR,rightLatestVR])

			if latestVR == rightLatestVR :
				toReturn.append((p, rightLatestVR, latestType, latestURL, leftLatestVR))
		else :
			if report_missing :
				toReturn.append(string.ljust(p,14)+'  has no '+str(p2))
	return toReturn

def addProgramToGraph(graph, program, version, revision, ptype, url, upgradeDetails):
	global installedPrograms
	if program in graph.keys():
		return;
	upgradeDetails[program] = {'version': version, 'revision': revision, 'type': ptype, 'url': url}
	graph[program] = {}
	deps,sols = CheckDependencies(program, version, revision, ptype, url, ['official_package', 'recipe'], mode='all', recursive=False)
	for s,d in zip(sols,deps):
		ver = s[1] + '-' + s[2]

		if s[0] not in installedPrograms or (d['lover'] != '' and d['lover'] is not None and GuessLatest([d['lover'], GuessLatest(installedPrograms[s[0]])]) == d['lover']):
			graph[program][s[0]] = s[1] + '-' + s[2]
			addProgramToGraph(graph, s[0], s[1], s[2], s[3], s[4], upgradeDetails)

# tsort' for the actual sorting. Keeps track of detected cycles in the global
# cycles.
def tsort2(item, graph, keys, ls, depth, parents):
	global cycles
	ind = ' '*depth
	if item is not None:
		k = item
		keys.remove(item)
	else:
		if len(keys) > 0:
			k = keys.pop()
		else:
			return
	
	dbprint(ind+"picked " + k + ": " + ', '.join(graph[k].keys()))
	for x in graph[k].keys():
		if x in keys:
			il = tsort2(x, graph, keys, [], depth+1, parents+[k])
			ls = il + ls
		else:
			if x in parents:
				dbprint(ind+"WARNING: cycle detected between "+x+" and "+k)
				ecyc = None
				for cyc in cycles:
					if ecyc is not None:
						if x in cyc or k in cyc:
							cycles.discard(cyc)
							cycles.discard(ecyc)
							cycles.add(cyc | ecyc)
							break
					elif x in cyc:
						cycles.discard(cyc)
						cycles.add(cyc | set([k]))
						ecyc = cyc
					elif k in cyc:
						cycles.discard(cyc)
						cycles.add(cyc | set([k]))
						ecyc = cyc
				#cycles = newcycles
				if ecyc is None:
					cycles.add(frozenset([x,k]))
			else:
				dbprint(ind+" reached "+x+", already completed")
	ls = [k] + ls
	dbprint(ind+"final ls: " + ', '.join(ls))
	return ls

def tsort(graph):
	keys = set(graph.keys())
	ls = []
	while len(keys)>0:
		dbprint("============")
		il = tsort2(None, graph, keys, [], 1,[])
		ls = il + ls
	ls.reverse()
	return ls

goboPrograms = getGoboVariable('goboPrograms')
goboSettings = getGoboVariable('goboSettings')
goboLinks    = getGoboVariable('goboLinks')

localdirs = [ '/Mount/Cloop/Programs', '/Mount/CD-ROM/Depot/Packages/', '/Depot/Packages', os.path.abspath('.')]

cycles = set()

graph = {}
upgradeDetails = {}
installedPrograms = {}
if os.path.exists('cache'):
	f = open('cache', 'r')
	graph = cPickle.load(f)
	upgradeDetails = cPickle.load(f)
	f.close()
	installed = GetAvailable(['installed'])['installed']['programs']
	for prog in installed.keys():
		versions = installed[prog]
		installedPrograms[prog] = []
		for v,revisions in versions.iteritems():
			for r in revisions.keys():
				installedPrograms[prog].append(v+'-'+r)
else:
	availables = GetAvailable(['installed', 'recipe', 'official_package'], localdirs, False, hook=consoleProgressHook, accessWeb=True)
	installed = availables['installed']['programs']
	for prog in installed.keys():
		versions = installed[prog]
		installedPrograms[prog] = []
		for v,revisions in versions.iteritems():
			for r in revisions.keys():
				installedPrograms[prog].append(v+'-'+r)
	l = applyFilter(availables, [['installed'], '<', ['recipe', 'official_package']], False)
	i=0
	for x in l:
		i+=1
		p=x[0];
		vers = Split_Version_Revision(x[1]) #x[1].split('-')
		ptype = x[2]
		url = x[3]
		if len(vers) < 2:
			vers = (vers[0], None)
		dbprint("adding "+p+": "+str(i)+"/"+str(len(l)))
		addProgramToGraph(graph, p, vers[0], vers[1], ptype, url, upgradeDetails)
		dbprint("added "+p)
	f = open('cache', 'w')
	cPickle.dump(graph, f, protocol = cPickle.HIGHEST_PROTOCOL)
	cPickle.dump(upgradeDetails, f, protocol = cPickle.HIGHEST_PROTOCOL)
	f.close()

dbprint("starting sort...")
ls = tsort(graph)
print "[ ] Program                                                            Installed"
for x in ls:
	upg = upgradeDetails[x]
	ver = Join_Version_Revision(upg['version'],upg['revision'])
	insVer = "None"
	if installedPrograms.has_key(x):
		insVer = GuessLatest(installedPrograms[x])
	if not installedPrograms.has_key(x) or (GuessLatest([ver, insVer]) == ver and ver != insVer):
		tabbr = getTypeAbbr(upg['type'])
		out = "[%s] %s %s"%(tabbr, x, ver)
		out = out + (" " * (80-len(out)-len(insVer))) + insVer
		print out

if len(cycles)>0:
	sys.stderr.write("\nNote: the dependency graph was not acyclic. An arbitrary ordering has been used for these cycles:\n")
	for cyc in cycles:
		sys.stderr.write(" { " + ', '.join(cyc)+" }\n")