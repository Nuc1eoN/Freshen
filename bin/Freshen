#!/usr/bin/env python
# Freshen - finds and installs updates for GoboLinux systems.
# Copyright (C) 2007-2008 Michael Homer <=mwh>
# Distribution terms shown by Freshen --version.

import string, os, os.path, sys, pickle, time, functools

from GetAvailable      import GetAvailable
from GuessLatest       import GuessLatest
from CheckDependencies import *
from PythonUtils       import *
from TTYUtils          import *

import Freshen
import FreshenArgParser

def getTypeAbbr(type):
	return {
		'recipe': Screen.colours['green']+'R'+Screen.colours['normal'],
		'official_package': Screen.colours['brown']+'P'+Screen.colours['normal'],
		'installed': 'I',
		None: '?'
	}[type]
def puts(string):
	sys.stdout.write(string+'\n')

class FreshenUI(object):
	goboPrograms = getGoboVariable('goboPrograms')
	
	def __init__(self):
		self.args = FreshenArgParser.FreshenArgParser(self)
		self.freshen = None

	def error(self, message):
		Log_Error(message, 'Freshen')
	
	def log(self, message):
		Log_Normal(message, 'Freshen')
	
	def initFreshen(self):
		if not self.freshen:
			self.freshen = Freshen.Freshen(mode=self.args.mode, examineSet=self.args.examineSet, limit=self.args.limit, skipSet=self.args.skipSet, noCache=self.args.noCache, forceCache=self.args.forceCache)
		
	def showUpdates(self):
		self.initFreshen()
		systemUpgrades = {'Scripts': None, 'Compile': None, 'Freshen': None}
		typeCount = {'recipe': 0, 'official_package': 0, '_binary_recipe': 0 ,'total': 0}
		pb = ProgressBar(len(self.freshen.examineSet)+1, self.freshen.limit)
		try:
			for update in self.freshen.updates(progressMeter=pb):
				# Only output heading the first time, if there are any.
				if typeCount['total']==0:
					puts("[  ] Program%sInstalled"%(' '*(Screen.width-21)))
				# Keep track of how many of each type and in total there are
				typeCount[update[3]] += 1
				typeCount['total'] += 1
				
				# Remember if there are updates to system tools
				if update[0] in systemUpgrades: systemUpgrades[update[0]] = type
				
				if update[3] == 'recipe' and self.freshen.latestInstalled(update[0]) and os.path.exists(self.goboPrograms + '/' + update[0] + '/Current/Resources/UseFlags'):
					try:
						currentFlags = set(open(self.goboPrograms + '/' + update[0] + '/Current/Resources/UseFlags').readline().split())
					except:
						Log_Error('Resources/UseFlags data file for installed %s exists but is not readable.'%(update[0]), 'Freshen')
				else:
					currentFlags = set()
				
				self.outProg(update, typeCount, currentFlags)
		except Freshen.CacheWarning:
			exc_type, exc_obj, exc_tb = sys.exc_info()
			Log_Error(exc_obj.message, 'Freshen')
		finally:
			puts("%(recipe)i recipes, %(_binary_recipe)i binary recipes, %(official_package)i packages, %(total)i total"%typeCount)
			for prog in ('Scripts', 'Compile', 'Freshen'):
				if systemUpgrades[prog]:
					cmd = systemUpgrades[prog] == 'recipe' and 'Compile' or 'InstallPackage'
					Log_Error("An upgrade to %s is available. It is strongly recommended that you upgrade immediately with `%s %s`."%(prog, cmd, prog), 'Freshen')
	
	def outProg(self, update, typeCount=None, currentFlags=set()):
		program,version,revision,type,url,intBy,enabledFlags,disabledFlags = update
		ver = Join_Version_Revision(version, revision)
		
		# Initialise default values (uninstalled program)
		insVer = "None"
		pcol = Screen.colours['darkgreybg']
		
		insVer = str(self.freshen.latestInstalled(program))
		if insVer != 'None':
			pcol = ''
		if pcol == '':
			# Alternate colouring by row for easier reading
			if typeCount and typeCount['total']%2==0:
				pcol=Screen.colours['blue']
			else:
				pcol=Screen.colours['cyan']
		
		typeAbbr = getTypeAbbr(type)
		
		# Flag binary recipes
		if version.endswith('_bin') or program.endswith('-Bin'):
			typeAbbr = Screen.colours['red']+'B'+Screen.colours['normal']+typeAbbr
			typeCount['_binary_recipe'] += 1
		else: typeAbbr = ' ' + typeAbbr
		
		# Display which program has this as a dependency if it isn't already installed
		introducedByString = insVer == 'None' and '(' + intBy + ')' or ''
		
		normalColour = Screen.colours['normal']
		
		# Perform output: flags are wrapped vertically when they don't fit on one line
		# The physical length of output must be tracked, which is different to the
		# string length because of colours
		maxlen = Screen.width - 10
		out = "[%s] %s%s %s %s " % (typeAbbr, pcol, program, ver, introducedByString)
		# outlen will be updated, minlen is used to pad wrapped text to line up
		outlen = len(program) + len(ver) + len(introducedByString) + 8
		minlen = outlen
		# Whether the installed version has been output or not
		insverout = False
		out+= Screen.colours['normal']
		for flag in enabledFlags:
			# Do we need to wrap yet?
			if outlen + len(flag) + 2 < maxlen:
				outlen += len(flag) + 2
				if not currentFlags or flag in currentFlags:
					out += Screen.colours['green']
				else:
					out += Screen.colours['brightgreen']
				out += '+' + flag + ' '
			else:
				# If the current version hasn't been output (i.e. this is the first
				# line), tack it onto the end with the right padding to force it
				# against the margin.
				if not insverout:
					insverout = True
					out += pcol + ' '*(Screen.width-outlen-len(insVer)) + insVer+Screen.colours['normal']
				puts(out)
				# Initialise the padding for the next line to vertically line up with
				# the first flag.
				out = ' ' * minlen
				outlen = len(out)
		# Now the same thing for disabled flags
		for flag in disabledFlags:
			if outlen + len(flag) + 2 < maxlen:
				outlen += len(flag) + 2
				if flag in currentFlags:
					out += Screen.colours['red']
				else:
					out += Screen.colours['blue']
				out += '-' + flag + ' '
			else:
				if not insverout:
					insverout = True
					out += pcol + ' '*(Screen.width-outlen-len(insVer)) + insVer+Screen.colours['normal']
				puts(out)
				out = ' ' * minlen
				outlen = len(out)
		
		out += pcol
		# It's possible that the version hasn't been output yet; if not, do it.
		if not insverout:
			insverout = True
			out += ' '*(Screen.width-outlen-len(insVer)) + insVer
		puts(out+Screen.colours['normal'])

	# Parse the value of a shell variable out of a file (recipe), performing variable substitutions.
	def parse_var(string, variableDefinitions=None):
		from string import Template
		if not hasattr(parse_var, 'definitions'):
			parse_var.definitions = {
				'goboPrograms': getGoboVariable('goboPrograms'),
				'goboShared':   getGoboVariable('goboShared'),
				'goboSettings': getGoboVariable('goboSettings'),
				'goboLinks':    getGoboVariable('goboLinks'),
			}
		if not variableDefinitions:
			variableDefinitions = {}
		variableDefinitions.update(parse_var.variableDefinitions)
		for variable in variableDefinitions:
			t = Template(variableDefinitions[variable])
			variableDefinitions[variable] = t.safe_substitute(variableDefinitions)
		t = Template(string.split('=', 2)[1])
		return t.safe_substitute(variableDefinitions)
	
	def installUpdates(self):
		self.initFreshen()
		i=0
		postMessages = []
		programs = set()
		error = None
		ulist = []
		try:
			for update in self.freshen.updates():
				program,version,revision,type,url,intBy,enabledFlags,disabledFlags = update
				i+=1
				programs.add(program)
				ver = Join_Version_Revision(version, revision)
				Log_Normal("Installing update %i: %s %s..."%(i, program, ver), 'Freshen')
				self.outProg(update)
				self.freshen.installUpdate(update)
				ulist.append(update)
				rec = os.popen('GetRecipe %s %s'%(program, ver)).readline().strip()+'/Recipe'
				if os.path.exists(rec):
					file = open(rec, 'r')
					for line in file:
						if line.startswith('post_install_message='):
							postMessages.append((program, parse_var(line, {'target': '$goboPrograms/%s/%s' % (program,version)})))
							break
					file.close()
		except Freshen.InstallationError:
			exc_type, exc_obj, exc_tb = sys.exc_info()
			Log_Error("There was an error installing %s.\nThe update process will terminate.\nPlease review the errors above for details about the problem."%(exc_obj.program))
			error = exc_obj
		except Freshen.CacheWarning:
			exc_type, exc_obj, exc_tb = sys.exc_info()
			Log_Error(exc_obj.message, 'Freshen')
		finally:
			for program,version,revision,type,url,intBy,enabledFlags,disabledFlags in ulist:
				if os.system("UpdateSettings -c" + program):
					os.system("UpdateSettings -a "+program)
			if postMessages:
				Log_Normal("Some of the installed programs requested post-install messages be displayed:")
				for program,message in postMessages:
					puts("%s: %s"%(program, message))
			self.freshen.clearCache()
		if error:
			Log_Error("Because there was an error in installation, not all of your updates may have been installed. You should review the error messages above for details.")
			exit(1)
	
	def showVersion(self):
		puts("""
Freshen %(major)i.%(minor)i.%(revision)i%(prerelease)s
(C) 2007-2008 Michael Homer <=mwh>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""%(Freshen.version))
	
	def showHelp(self):
		puts("""
Checks for updated GoboLinux recipes and packages.

Usage: Freshen <mode> [<opts>] [<list>]

Modes:
(default)
	Display list of updates.
--help
	This help text.
--install
	Install <list> without upgrading any dependencies (equivalent to -U -s)
-U
	Install updates.
--version
	Display version and copyright information.

Options:
--exclude, -x <xlist>
	Exclude <xlist> from updating. Does not exclude other programs depending
	on <xlist>.
--force-cache, -c
	Force using cached updates data, rather than recalculating them.
--limit, -l <n>
	Only include the first <n> updates.
--no-cache, -C
	Force regenerating updates data, rather than reading from cache.
--shallow, -s
	Only include <list> and necessary dependencies.
--thorough
	Include deep updates to revisions and up-to-date dependencies.

Notes:
Run with no arguments, Freshen outputs a list of updates in the form:
[%(red)sB%(green)sR%(normal)s] Foo 2.0                                                                 1.0
The mnemonics mean:
%(green)sR%(normal)s Recipe will be used                    %(brown)sNew program%(normal)s
%(brown)sP%(normal)s Package will be used                   Other colours are for readability only
%(red)sB%(normal)s Binary recipe

If <list> is provided, Freshen examines only the programs in it and their
dependencies. If <list> is not provided, Freshen will examine all installed
programs.

Examples:
Freshen -x LibFoo LibBar -U Baz Quux
"""%Screen.colours)

def reportBug(exc_info):
	import traceback
	ex_type, ex_obj, ex_tb = exc_info
	Log_Error("ERROR: %s.%s: %s"% (ex_type.__module__, ex_type.__name__, ex_obj), 'Freshen')
	sys.stderr.write('\n')
	traceback.print_exception(ex_type, ex_obj, ex_tb)
	sys.stderr.write('\n')
	sys.stderr.write('Freshen %(major)s.%(minor)s.%(revision)s%(prerelease)s'%(Freshen.version))
	sys.stderr.write(' on python ' + '.'.join(map(str, sys.version_info)) + '\n')
	sys.stderr.write('arguments: %r\n'%(sys.argv))
	sys.stderr.write(Screen.colours['red'])
	sys.stderr.write("""
*** Freshen has encountered an internal error. Please send this report to
    gobolinux-users@lists.gobolinux.org with a description of what you were
    doing when the error occurred.
""")
	sys.stderr.write(Screen.colours['normal'])

try:
	ui = FreshenUI()
	# Execute the defined action
	ui.args.action()
	exit(0)
except KeyboardInterrupt:
	pass
except SystemExit:
	pass
except IOError:
	exc_type, exc_obj, exc_tb = sys.exc_info()
	import errno
	if exc_obj.errno in (errno.EINVAL, errno.EPIPE):
		sys.stderr.write("Freshen: broken pipe")
	else:
		reportBug(sys.exc_info())
except BaseException:
	reportBug(sys.exc_info())

finally: # Clear title on exit
	sys.stderr.write("\033]2;\007");
