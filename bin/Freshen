#!/usr/bin/env python
# Freshen - finds and installs updates for GoboLinux systems.
# Copyright (C) 2007-2008 Michael Homer <=mwh>
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import string
import os
import os.path
import sys
import pickle
import time
import functools

from GetAvailable      import GetAvailable
from GuessLatest       import GuessLatest
from CheckDependencies import *
from PythonUtils       import *
from TTYUtils          import *

import Freshen
import FreshenArgParser

def getTypeAbbr(type):
	return {
		'recipe': Screen.colours['green']+'R'+Screen.colours['normal'],
		'official_package': (Screen.colours['brown'] + 'P'
		                     + Screen.colours['normal']),
		'installed': 'I',
		None: '?'
	}[type]

def puts(string):
	sys.stdout.write(string + '\n')

class FreshenUI(object):
	goboPrograms = getGoboVariable('goboPrograms')
	
	def __init__(self):
		self.args = FreshenArgParser.FreshenArgParser(self)
		self.limit = self.args.limit
		self.freshen = None

	def error(self, message):
		Log_Error(message, 'Freshen')

	def log(self, message):
		Log_Normal(message, 'Freshen')

	def initFreshen(self):
		if not self.freshen:
			self.freshen = Freshen.Freshen(mode=self.args.mode,
			                               examineSet=self.args.examineSet,
			                               skipSet=self.args.skipSet,
			                               noCache=self.args.noCache,
			                               forceCache=self.args.forceCache,
			                               types=self.args.types)

	def showUpdates(self):
		self.initFreshen()
		systemUpgrades = {'Scripts': None, 'Compile': None, 'Freshen': None}
		typeCount = {
			'recipe': 0,
			'official_package': 0,
			'_binary_recipe': 0 ,
			'total': 0
			}
		pb = ProgressBar(len(self.freshen.examineSet) + 1, self.limit, True)
		try:
			updates = self.freshen.updates(onExamine=pb.inc)
			for update in updates:
				# Only output heading the first time, if there are any.
				if typeCount['total']==0:
					puts("[  ] Program%sInstalled" %
					     (' ' * (Screen.width - 21)))
				# Keep track of how many of each type and in total there are
				typeCount[update[3]] += 1
				typeCount['total'] += 1
				
				# Remember if there are updates to system tools
				if update[0] in systemUpgrades:
					systemUpgrades[update[0]] = type
				
				if (update[3] == 'recipe' and
					self.freshen.latestInstalled(update[0])
					and os.path.exists(self.goboPrograms + '/'
										+ update[0] +
										'/Current/Resources/UseFlags')):
					try:
						currentFlags = set(open(
												self.goboPrograms +
												'/' + update[0] +
												'/Current/Resources/UseFlags')
											.readline().split())
					except:
						Log_Error('Resources/UseFlags data file for '
						          'installed %s exists but is not '
								  'readable.' % (update[0]), 'Freshen')
				else:
					currentFlags = set()
				
				self.outProg(update, typeCount, currentFlags)
				pb.inc2()
				if typeCount['total'] == self.limit: break
		except Freshen.CacheWarning:
			exc_type, exc_obj, exc_tb = sys.exc_info()
			Log_Error(exc_obj.message, 'Freshen')
		finally:
			pb.clear()
			puts("%(recipe)i recipes, %(_binary_recipe)i binary recipes, "
			     "%(official_package)i packages, %(total)i total" % typeCount)
			for prog in ('Scripts', 'Compile', 'Freshen'):
				if systemUpgrades[prog]:
					if 'recipe' == systemUpgrades[prog]:
						cmd = 'Compile'
					else:
						cmd = 'InstallPackage'
					Log_Error("An upgrade to %s is available. It is strongly"
					          "recommended that you upgrade immediately with"
							  " `%s %s`."%(prog, cmd, prog), 'Freshen')

	def outFlag(self, flag, signal, currentFlags, currentlyEnabledColour,
		        currentlyDisabledColour):
		out = ''
		if not currentFlags or flag in currentFlags:
			out += currentlyEnabledColour
		else:
			out += currentlyDisabledColour
		out += signal + flag + ' '
		return out

	def outProg(self, update, typeCount=None, currentFlags=set()):
		(program, version, revision, type, url, intBy, enabledFlags,
		 disabledFlags) = update
		ver = Join_Version_Revision(version, revision)
		
		# Initialise default values (uninstalled program)
		insVer = "None"
		pcol = Screen.colours['darkgreybg']
		
		insVer = str(self.freshen.latestInstalled(program))
		if insVer != 'None':
			# Alternate colouring by row for easier reading
			if typeCount and typeCount['total'] % 2 == 0:
				pcol = Screen.colours['blue']
			else:
				pcol = Screen.colours['cyan']
		
		typeAbbr = getTypeAbbr(type)
		
		# Flag binary recipes
		if version.endswith('_bin') or program.endswith('-Bin'):
			typeAbbr = (Screen.colours['red'] + 'B' +
			            Screen.colours['normal'] + typeAbbr)
			typeCount['_binary_recipe'] += 1
		else: typeAbbr = ' ' + typeAbbr
		
		# Display which program has this as a dependency if it isn't
		# already installed.
		introducedByString = insVer == 'None' and '(' + intBy + ')' or ''
		
		# Perform output. Flags are wrapped vertically when they don't
		# fit on one line.
		# The physical length of output must be tracked, which is
		# different to the string length because of colours
		maxlen = Screen.width - 10
		out = "[%s] %s%s %s %s " % (typeAbbr, pcol, program, ver, 
		                            introducedByString)
		# outlen will be updated, minlen is used to pad wrapped text so
		# that it lines up.
		outlen = len(program) + len(ver) + len(introducedByString) + 8
		minlen = outlen
		# Whether the installed version has been output or not
		insverout = False
		out+= Screen.colours['normal']
		for flags, sig, enCol, disCol in (
				(enabledFlags, '+', Screen.colours['green'],
				 Screen.colours['brightgreen']),
				(disabledFlags, '-', Screen.colours['red'],
				 Screen.colours['blue']),
			):
			for flag in flags:
				# Do we need to wrap yet?
				if outlen + len(flag) + 2 >= maxlen:
					# If this is the first line, pad out and output the version
					if not insverout:
						insverout = True
						out += (pcol + ' ' *
						        (Screen.width - outlen - len(insVer)) +
								insVer + Screen.colours['normal'])
					puts(out)
					# Initialise the padding for the next line to
					# vertically line up with the first flag.
					out = ' ' * minlen
					outlen = len(out)
				outlen += len(flag) + 2
				out += self.outFlag(flag, sig, currentFlags, enCol, disCol)
		
		# It's possible this is still the first line; if so, output the version
		if not insverout:
			out += pcol + ' ' * (Screen.width-outlen-len(insVer)) + insVer
		puts(out + Screen.colours['normal'])

	# Parse the value of a shell variable out of a file (recipe),
	# performing variable substitutions.
	def parse_var(string, variableDefinitions=None):
		from string import Template
		if not hasattr(parse_var, 'definitions'):
			parse_var.definitions = {
				'goboPrograms': getGoboVariable('goboPrograms'),
				'goboShared':   getGoboVariable('goboShared'),
				'goboSettings': getGoboVariable('goboSettings'),
				'goboLinks':    getGoboVariable('goboLinks'),
			}
		if not variableDefinitions:
			variableDefinitions = {}
		variableDefinitions.update(parse_var.variableDefinitions)
		for variable in variableDefinitions:
			t = Template(variableDefinitions[variable])
			variableDefinitions[variable] = \
				t.safe_substitute(variableDefinitions)
		t = Template(string.split('=', 2)[1])
		return t.safe_substitute(variableDefinitions)

	def installUpdates(self):
		self.initFreshen()
		i = 0
		postMessages = []
		programs = set()
		error = None
		ulist = []
		try:
			for update in self.freshen.updates():
				(program, version, revision, type, url, intBy, enabledFlags,
					disabledFlags) = update
				i += 1
				programs.add(program)
				ver = Join_Version_Revision(version, revision)
				sys.stderr.write("\033]2;Installing update %i: %s %s\007" %
				                 (i, program, ver))
				Log_Normal("Installing update %i: %s %s..." %
				           (i, program, ver),
						   'Freshen')
				self.outProg(update)
				self.freshen.installUpdate(update)
				ulist.append(update)
				rec = (os.popen('GetRecipe %s %s' % (program, ver))
				       .readline().strip() + '/Recipe')
				if os.path.exists(rec):
					file = open(rec, 'r')
					for line in file:
						if line.startswith('post_install_message='):
							postMessages.append((program,
								parse_var(line,
										  {'target': '$goboPrograms/%s/%s' %
										              (program,version)
										  }
									)
								)
							)
							break
					file.close()
				if i == self.limit:
					break
		except Freshen.InstallationError:
			exc_type, exc_obj, exc_tb = sys.exc_info()
			Log_Error("There was an error installing %s.\n"
			          "The update process will terminate.\n"
			          "Please review the errors above for details about"
			          " the problem." % (exc_obj.program))
			error = exc_obj
		except Freshen.CacheWarning:
			exc_type, exc_obj, exc_tb = sys.exc_info()
			Log_Error(exc_obj.message, 'Freshen')
		finally:
			for (program, version, revision, type, url, intBy,
				 enabledFlags, disabledFlags) in ulist:
				if os.system("UpdateSettings -c " + program):
					os.system("UpdateSettings -a " + program)
			if postMessages:
				Log_Normal("Some of the installed programs requested "
				           "post-install messages be displayed:")
				for program,message in postMessages:
					puts("%s: %s" % (program, message))
			self.freshen.clearCache()
		if error:
			Log_Error("Because there was an error in installation, not "
			          "all of your updates may have been installed. "
					  "You should review the error messages above for "
					  "details.")
			exit(1)

	def showVersion(self):
		puts("""
Freshen %(major)i.%(minor)i.%(revision)i%(prerelease)s
(C) 2007-2008 Michael Homer <=mwh>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
""" % (Freshen.version))

	def showHelp(self):
		puts("""
Checks for updated GoboLinux recipes and packages.

Usage: Freshen <mode> [<opts>] [<list>]

Modes:
(default)
	Display list of updates.
--help
	This help text.
--install
	Install <list> without upgrading any dependencies (equivalent to -U -s)
--unordered
	Don't order updates or resolve dependencies.
-U
	Install updates.
--version
	Display version and copyright information.

Options:
--exclude, -x <xlist>
	Exclude <xlist> from updating. Does not exclude other programs depending
	on <xlist>.
--force-cache, -c
	Force using cached updates data, rather than recalculating them.
--limit, -l <n>
	Only include the first <n> updates.
--no-cache, -C
	Force regenerating updates data, rather than reading from cache.
--shallow, -s
	Only include <list> and necessary dependencies.
--thorough
	Include deep updates to revisions and up-to-date dependencies.

Notes:
Run with no arguments, Freshen outputs a list of updates in the form:
[%(red)sB%(green)sR%(normal)s] Foo 2.0                                                                 1.0
The mnemonics mean:
%(green)sR%(normal)s Recipe will be used                    %(brown)sNew program%(normal)s
%(brown)sP%(normal)s Package will be used                   Other colours are for readability only
%(red)sB%(normal)s Binary recipe

If <list> is provided, Freshen examines only the programs in it and their
dependencies. If <list> is not provided, Freshen will examine all installed
programs.

Examples:
Freshen -x LibFoo LibBar -U Baz Quux
""" % Screen.colours)

def reportBug(exc_info):
	import traceback
	ex_type, ex_obj, ex_tb = exc_info
	Log_Error("ERROR: %s.%s: %s" %
	          (ex_type.__module__, ex_type.__name__, ex_obj),
			  'Freshen')
	sys.stderr.write('\n')
	traceback.print_exception(ex_type, ex_obj, ex_tb)
	sys.stderr.write('\n')
	sys.stderr.write('Freshen %(major)s.%(minor)s.%(revision)s%(prerelease)s' %
	                 (Freshen.version))
	sys.stderr.write(' on python ' +
	                 '.'.join(map(str, sys.version_info)) + '\n')
	sys.stderr.write('arguments: %r\n'%(sys.argv))
	sys.stderr.write(Screen.colours['red'])
	sys.stderr.write("""
*** Freshen has encountered an internal error. Please send this report to
    gobolinux-users@lists.gobolinux.org with a description of what you were
    doing when the error occurred.
""")
	sys.stderr.write(Screen.colours['normal'])

try:
	ui = FreshenUI()
	# Execute the defined action
	ui.args.action()
	exit(0)
except KeyboardInterrupt:
	pass
except SystemExit:
	pass
except IOError:
	exc_type, exc_obj, exc_tb = sys.exc_info()
	import errno
	if exc_obj.errno in (errno.EINVAL, errno.EPIPE):
		sys.stderr.write("Freshen: broken pipe")
	else:
		reportBug(sys.exc_info())
except BaseException:
	reportBug(sys.exc_info())
finally: # Clear title on exit
	sys.stderr.write("\033]2;\007");
