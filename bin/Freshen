#!/usr/bin/ruby

# Add libraries
#This is for the global libraries
$: << "/System/Links/Libraries/ruby/site_ruby/1.8/"
#And this is for mine
dirname = File.dirname(`readlink -f #{$0}`)
$: << File.expand_path("#{dirname}/../lib/")

require 'screen'
require 'version'
require 'gobo'
require 'gobo/parseconfig'
require 'parseconfig' # Until a new Compile release is out
require 'merge'
require 'progressbar'
require 'tsort'
require 'depsort'
require 'freshen-functions'

class Freshen < GoboApplication
	def initialize()
		super()
		@dirname = File.dirname(`readlink -f #{$0}`)
		@progs = nil
		@recipes = nil
		@packages = nil
		settingspath = File.expand_path("#{@dirname}/../../Settings/Freshen") + "/Freshen.conf"
		settingspath = File.expand_path("#{@dirname}/../Settings/Freshen") + "/Freshen.conf" if !File.exists?(settingspath)
		@config = GoboParseConfig.new(settingspath)
		if @config['verbosity']=='error'
			@logLevel = 10
		elsif @config['verbosity']=='quiet'
			@logLevel = 20
		elsif @config['verbosity']=='normal'
			@logLevel = 30
		elsif @config['verbosity']=='verbose'
			@logLevel = 40
		elsif @config['verbosity']=='debug'
			@logLevel = 50
		end
		['recipeCacheTimeout','downloadTimeout','programsCacheTimeout'].each {|x|
			if match=@config[x].match(/([0-9.]+)([smhdw])/)
				match[2]=='s' and mul = 1
				match[2]=='m' and mul = 60
				match[2]=='h' and mul = 3600
				match[2]=='d' and mul = 86400
				match[2]=='w' and mul = 604800
				@config[x] = match[1].to_i*mul
			end
		}
		addOptionBoolean("upgrades", ["-n"], "Include upgrades#{@config['showUpgrades']=='yes' and ' [default]' or ''}")
		addOptionBoolean("no-upgrades", ["-N"], "Do not include upgrades#{@config['showUpgrades']=='no' and ' [default]' or ''}")
		addOptionBoolean("downgrades", ["-d"], "Include downgrades#{@config['showDowngrades']=='yes' and ' [default]' or ''}")
		addOptionBoolean("no-downgrades", ["-D"], "Do not include downgrades.#{@config['showDowngrades']=='no' and ' [default]' or ''}")
		addOptionBoolean("no-cache", ["-C"], "Do not use cached data for /Programs")
		addOptionBoolean("cache-only", ["-c"], "Update caches only")
		addOptionBoolean("binaries", ["-b"], "Include binary packages#{@config['binaries']=='yes' and ' [default]' or ''}")
		addOptionBoolean("no-binaries", ["-B"], "Do not include binary packages#{@config['binaries']=='no' and ' [default]' or ''}")
		addOptionBoolean("recipes", ["-r"], "Include recipes#{@config['recipes']=='yes' and ' [default]' or ''}")
		addOptionBoolean("no-recipes", ["-R"], "Do not include recipes#{@config['recipes']=='no' and ' [default]' or ''}")
#		addOptionEntry("netmode", [], "Set netMode to (online|offline|always)")
		addOptionBoolean("upgrade-system", ["-U"], "Upgrade entire system, excluding items blocked by -x")
		addOptionEntry("limit", ["-l"], "Limit update list to first <n> packages")
		addOptionEntry("lower-limit", ["-L"], "Skip the first <n> packages of update list")
		addOptionEntry("info", ["-i"], "Get information on <program>")
		addOptionBoolean("excluding", ["-x"], "Exclude <list> from output.")
		addOptionBoolean("empty-tree", ["-e"], "Behave as if installed program tree were empty")
      self.description = "Checks for updated GoboLinux recipes and packages."
      self.credits     = "By Michael Homer <michael@e.geek.nz>"
      self.usage       = "[<opts>] [<list>]"
      self.example     = "-U -l 5 -R"
      self.helpOnNoArguments = false
      @version         = "2.1"
      self.notes = <<END_OF_NOTES
Run with no arguments, Freshen outputs a list of updates in the form:
[I#{Screen.colour['cyan']}U#{Screen.colour['normal']}X] #{Screen.colour['red']}Foo 2.0#{Screen.colour['normal']}                                                                1.0
The mnemonics mean:                Colour code:
 I Installed                       #{Screen.colour['green']}Recipe        #{Screen.colour['brown']}Binary#{Screen.colour['normal']}
 #{Screen.colour['cyan']}U#{Screen.colour['normal']} Upgrade                         #{Screen.colour['blue']}Recipe+Binary #{Screen.colour['red']}Downgrade#{Screen.colour['normal']}
 #{Screen.colour['red']}D#{Screen.colour['normal']} Downgrade
 #{Screen.colour['green']}N#{Screen.colour['normal']} New program
 R Recipe available
 B Binary available
 X Recipe and binary available
 
If <list> is provided, Freshen examines only the programs in it and their dependencies, unless the -x flag is enabled. If <list> is not provided, Freshen will examine all installed programs.
END_OF_NOTES
	end
	def run
		if options('upgrades')
			@config['showUpgrades'] = 'yes'
		elsif options('no-upgrades')
			@config['showUpgrades'] = 'no'
		end
		if options('binaries')
			@config['binaries'] = 'yes'
		elsif options('no-binaries')
			@config['binaries'] = 'no'
		end
		if options('recipes')
			@config['recipes'] = 'yes'
		elsif options('no-recipes')
			@config['recipes'] = 'no'
		end
		if options('downgrades')
			@config['showDowngrades'] = 'yes'
		elsif options('no-downgrades')
			@config['showDowngrades'] = 'no'
		end
# Netmode doesn't work. Does it need to be there at all?
#		if options('netmode')
#			@config['netMode'] = options('netmode')
#		end
		if options('limit')
			@config['limit'] = options('limit').to_i
		end
		if options('lower-limit')
			@config['lower-limit'] = options('lower-limit').to_i
		end
		@config['except'] = [] if !@config['except']
		@config['onlyExamine'] = [] if !@config['onlyExamine']
		if options('excluding')
			@config['except'] = ARGV.dup
			@config['except'].each_index {|i|
				@config['except'][i] = getTrueCase @config['except'][i]
			}
		elsif not @config['except'].length>0
			@config['onlyExamine'] = ARGV.dup
		end
		@config['emptyTree'] = options('empty-tree')
		@compileConfig = GoboParseConfig.new("#{@config['goboRoot']}/System/Settings/Compile/Compile.conf")
		@getAvailableConfig = GoboParseConfig.new("#{@config['goboRoot']}/System/Settings/Scripts/GetAvailable.conf")
		if options('cache-only')
			self.updateCaches
		elsif options('upgrade-system')
			self.upgradeSystem
		elsif options('info')
			self.info(options('info'))
		else
			self.sysStatus(@config['showUpgrades']=='yes',@config['showDowngrades']=='yes')
		end
		puts "\033];\007"
	end
	def info(prog)
		self.genTree
		self.genPackages
		self.getProgs
		found = false
		recipe = false
		description = newver = versionstring = size = recipefile = depof = false
		if !(prog = getTrueCase(prog))
			self.logError "Cannot fetch information. Program not found."
			return
		end
		# Find the recipe file
		# TODO: remove this. We shouldn't be searching /F/C/R, we should be using our own cache.
		# Using /F/C/R makes us liable to problems when somebody hasn't run UpdateSettings recently.
		# However, the cache doesn't account for LocalRecipes. Fix? Maybe use a heuristic and check for
		# paths containing "Local"?
		if @recipes[prog]
			present = false
			if @compileConfig['compileRecipeDirs'].is_a?(Array)
				@compileConfig['compileRecipeDirs'].each {|dir|
					if File.exists?("#{dir}/#{prog}/#{@recipes[prog].at(-1)}/Recipe")
						present = true
						recipefile = "#{dir}/#{prog}/#{@recipes[prog].at(-1)}/Recipe"
						break
					end
				}
			end
			if !present
				self.getRecipe(prog,@recipes[prog].at(-1))
				recipefile = "#{@compileConfig['compileGetRecipeDir']}/#{prog}/#{@recipes[prog].at(-1)}/Recipe"
			end
		end
		
		installed = @progs[prog] if @progs[prog]
		newver = @recipes[prog].at(-1) if @recipes[prog]
		newver = @packages[prog].at(-1) if @packages[prog] and (!newver or @packages[prog].at(-1)>newver)
		if newver>installed
			nvcol = Screen.colour['red']
		else
			nvcol = Screen.colour['cyan']
		end
		# Merge recipes and packages versions, sort and remove duplicates
		vers = ((@recipes[prog] ? @recipes[prog] : Array.new) | (@packages[prog] ? @packages[prog] : Array.new))
		vers.sort!
		vers.uniq!
		# Add the mnemonic colours
		versionstring = ""
		vslength = 0 # This is used to insert hard line breaks and wordwrap the version list.
		wrappos = Screen.width-24 # We can't use wordwrap() because of the escape sequences
		vers.each {|ver|
			if vslength+ver.to_s.length>wrappos
				versionstring+="\n"+" "*23
				vslength = 0
			end
			vslength+= ver.to_s.length
			if @recipes[prog] and @packages[prog] and @recipes[prog].index(ver) and @packages[prog].index(ver)
				versionstring+= "#{Screen.colour['blue']+ver.to_s+Screen.colour['normal']} "
			elsif @recipes[prog] and @recipes[prog].index(ver)
				versionstring+= "#{Screen.colour['green']+ver.to_s+Screen.colour['normal']} "
			elsif @packages[prog] and @packages[prog].index(ver)
				versionstring+= "#{Screen.colour['brown']+ver.to_s+Screen.colour['normal']} "
			end
		}
		# There's no way to get package descriptions without fetching them, so we have to rely on
		# recipes or /Programs entries. There should be a better way, although there aren't many
		# package-only programs any more.
		desclines = []
		if recipefile and File.exists?(recipefile.sub(/Recipe$/,'')+"Resources/Description")
			desclines = File.readlines(recipefile.sub(/Recipe$/,'')+"Resources/Description")
		elsif @progs[prog] and File.exists?("#{@config['goboRoot']}/Programs/#{prog}/Current/Resources/Description")
			desclines = File.readlines("#{@config['goboRoot']}/Programs/#{prog}/Current/Resources/Description")
		end
		desclines.each {|l|
			if l =~ /\[Description\]/
				description = wordwrap(l[14,l.length], 24) # 24 is the space taken by the label
			end
		}

		# Only produce list of programs that depend on prog if we're at verbose or higher, because
		# it requires generating the whole tree
		if @logLevel>=40
 			pl = produceUpdatesList(true, false, true)
 			dl = []
 			pl.each {|k,v|
	 			dl.push k if v.include?(prog)
 			}
 			if dl.length>0
 				depof = wordwrap(dl.join(", "), 24)
 			end
 		end
		
		if recipefile
			rc = GoboParseConfig.new(recipefile)
			size = rc['file_size'].to_i if rc['file_size']
		end
		puts "  * #{Screen.colour['green']+prog+Screen.colour['normal']}"
		puts "    Description:       #{description}" if description
		puts "    Installed Version: #{Screen.colour['cyan']}#{installed}#{Screen.colour['normal']}" if installed
		puts "    Newest Version:    #{nvcol}#{newver}#{Screen.colour['normal']}" if newver
		puts "    Versions:          #{versionstring}" if versionstring
		puts "    Dependency of:     #{depof}" if depof
		puts "    Size:              #{Gobo.smartSize(size)}" if size
		puts "    Recipe: #{recipefile}" if recipefile
	end

	def upgradeSystem
		self.genTree
		self.genPackages
		self.getProgs
		rp = @recipes.clone
		rp.merge(@packages)
		pvs = Hash.new
		sz = 0

		toupdate = produceUpdatesList(true,false, false)
		
		if @config['lower-limit']
			toupdate = toupdate[@config['lower-limit']..toupdate.length]
		end
		if @config['limit']
			toupdate = toupdate[0, @config['limit']]
		end
		if @logLevel>=40
			toupdate.each {|p,v|
				puts progStatus(p)
			}
		end
		i = 0
		toupdate.each {|p,v|
			i+= 1
			#szs = ", #{Gobo.smartSize(sz)} to go..." if sz>0
			self.logNormal "\033]2;Freshen: Upgrading #{p}, #{i}/#{toupdate.size}\007Upgrading #{i}/#{toupdate.size}..."
			puts progStatus(p) if @logLevel>=40
			self.upgrade(p)
			#sz-=@packsizes[p] if @packsizes[p]
		}
		toupdate.each {|p,v|
			i+= 1
			self.logNormal "\033]2;Freshen: Updating settings\007Updating #{p} Settings..."
			system "UpdateSettings #{p}"
		}
		if toupdate.length==0
			self.logNormal "Nothing to do."
		end
		@config['recipeCacheTimeout'] = 0
		self.genProgs
	end
	def upgrade(prog)
		self.logNormal "Upgrading #{prog}..."
		self.genTree
		self.genPackages
		self.getProgs
		if !@recipes[prog] and !@packages[prog]
			found = false
			@recipes.each_key {|key|
				if key.downcase==prog.downcase
					prog = key
					found = true
					break
				end
			}
			if !found
				@packages.each_key {|key|
					if key.downcase==prog.downcase
						prog = key
						break
					end
				}
			end
		end
		newver = recipe = package = nil
		if @recipes[prog] and @packages[prog] and @config['binaries']=='yes' and @config['recipes']=='yes'
			if @recipes[prog].at(-1)<@packages[prog].at(-1)
				newver = @packages[prog].at(-1)
				package = true
			elsif @recipes[prog].at(-1)>@packages[prog].at(-1)
				newver = @recipes[prog].at(-1)
				recipe = true
			else
				newver = @recipes[prog].at(-1)
				recipe = package = true
			end
		elsif @recipes[prog] and @config['recipes']=='yes'
			newver = @recipes[prog].at(-1)
			recipe = true
		elsif @packages[prog] and @config['binaries']=='yes'
			newver = @packages[prog].at(-1)
			package = true
		end
		prefs = @config['preference'].split(',')
		if prefs[0]=='recipe' and recipe
			self.logNormal "First preference recipe, got recipe."
			self.upgradeCompile(prog,newver)
		elsif prefs[0]=='binary' and package
			self.logNormal "First preference binary, got binary."
			self.upgradePackage(prog,newver)
		elsif prefs[1]=='recipe' and recipe
			self.logNormal "First preference binary, no binary."
			self.logNormal "Got a recipe though."
			self.upgradeCompile(prog,newver)
		elsif prefs[1]=='binary' and package
			self.logNormal "First preference recipe, no recipe."
			self.logNormal "Got a binary though."
			self.upgradePackage(prog,newver)
		else
			self.logError "Nothing matches your criteria."
		end
	end
	def upgradeCompile(prog,ver)
		self.logNormal "Feeding this off to Compile..."
		if !File.writable?("#{@config['goboRoot']}/Files/Compile/Sources")
			sudo = "sudo -u #0 "
		end
		r  = system("#{sudo} Compile -G -U -D -b #{prog} #{ver}")
		if !r
#			v = ver.to_s.gsub(/-r.*$/, '')
#			r = system "#{sudo} SymlinkProgram #{prog} #{v}"
#			if !r
			# This behaviour needs to be better defined. Perhaps an option to continue over the top?
				self.logError "Compile failed of #{prog} #{ver}. Terminating. Programs data cache has not been updated. Use Freshen -C to do this if necessary."
				exit
#			end
		end
	end
	def upgradePackage(prog,ver)
		gotone = false
		pfn = ""
		self.logNormal('Using package, will call InstallPackage')
		# Strip -r1 off the end of packages. Some do have it, but InstallPackage doesn't need it and
		# chokes if it's present when it shouldn't be.
		vers = "#{ver}"
		vers.gsub!(/-r1$/, '')
		sudo = ""
		if File.writable?("#{@config['goboRoot']}/Programs")
			sudo = "sudo -u #0 "
		end
		r = system("#{sudo} InstallPackage -k -U -s keep -b -D -u keep #{prog} #{vers}")
		if !r
			self.logNormal "Initial InstallPackage failed. Retrying will null revision..."
			ov = vers.clone
			if ov!=vers.gsub!(/-r.*$/, '')
				if system("#{sudo} InstallPackage -k -U -s keep -b -D -u keep #{prog} #{vers}")
					return
				end
			end
			self.logError "InstallPackage failed. Terminating."
			exit
		end
	end
	def getRecipe(prog,ver)
		system "GetRecipe #{prog} #{ver}"
		return
	end
	def getProgs
		return @progs if @progs and @progs.length>0
		progs = Hash.new
#		pcpath = File.expand_path("#{@dirname}/../../Settings/Freshen") + "/ProgramsCache.rb"
		pcpath = "#{@config['tmpDir']}/ProgramsCache.rb"
		if File.exists?(pcpath) and File.ctime(pcpath)>Time.now-@config['programsCacheTimeout'] and !options('no-cache')
			#self.logVerbose "Reading /Programs data from cache"
			eval(File.open(pcpath).read)
			@progs = progs
		else
			self.genProgs
		end
	end
	def genProgs
		self.logNormal "Generating list of installed programs..."
		pcpath = "#{@config['tmpDir']}/ProgramsCache.rb"
		@progs = Hash.new
		pcache = "progs = {\n"
		rp = @recipes.dup
		rp.merge(@packages)
		pb = ProgressBar.new(rp.size,1)
		rp.each_key {|prog|
			curver = `readlink -f #{@config['goboRoot']}/Programs/#{prog}/Current`
			curver.match(/Current$/) and next
			curver.gsub!(/.*\/(.+?)\n/,"\\1")
			curver == "" and curver = 0
			ver = Version.new(curver)
			@progs[prog] = ver
			if File.exists?("#{@config['goboRoot']}/Programs/#{prog}")
					Dir.foreach("#{@config['goboRoot']}/Programs/#{prog}") {|fn|
						next if fn=='.'||fn=='..'||fn=='Current'||fn=='Settings'||fn=='Variable'
						v = Version.new(fn)
						if v>ver
							ver = v
							curver = fn
						end
					}
					if File.exists?("#{@config['goboRoot']}/Programs/#{prog}/#{ver}/Resources/Revision")
						rv = (File.readlines("#{@config['goboRoot']}/Programs/#{prog}/#{ver}/Resources/Revision"))[0].strip
						ver = Version.new("#{ver}-#{rv}") if !rv.nil? and rv!=''
						curver = "#{ver}"
					end
					@progs[prog] = ver
			end
			pcache+= "'#{prog}'=>Version.new('#{curver}'),\n"
			pb.inc
			pb.draw
		}
		print ' '*Screen.width+"\015"
		pcache+= "}"
		self.logVerbose "Saving /Programs data to cache"
		pc = File.open(pcpath,"w")
		pc.puts(pcache)
		pc.close
	end
	def genPackages
		packages = Hash.new
		if @config['binaries']=='yes'
			self.packagesListLines.each {|line|
				# e.g. ALSA-Utils--1.0.0rc2--i686.tar.bz2
				parts = line.split('--')
				name = parts[0]
				ver  = parts[1]
				if parts[2]==@config['arch']+".tar.bz2\n"
					packages[name] = Array.new unless packages[name]
					packages[name].push(Version.new(ver))
				end
			}
			@packages = packages
			return
			pd = self.packagesDataLines.join("\n")
			@packsizes = Hash.new
			packages.each_key {|key|
				packages[key] = packages[key].sort
				safekey = key.dup
				safekey.gsub!('+',"\\\\+")
				if match = pd.match(/#{safekey}--#{packages[key].at(-1)}--#{@config['arch']}.*?([0-9.]+)([kM])/)
					mul = 1024 if match[2]=='k'
					mul = 1048576 if match[2]=='M'
					@packsizes[key] = match[1].to_f*mul
				end
			}
		end
		@packages = packages
	end
	def updateCaches
		@config['recipeCacheTimeout'] = 0
		self.genTree
		self.genPackages
		self.genProgs
	end
	def sysStatus(showupgrades,showdowngrades)
		exl = ""
		if @config['except'].length>0
			anditem = @config['except'].pop
			exl = ", excluding "+@config['except'].join(', ')+(@config['except'].length>0 ? " and " : '')+anditem
			@config['except'].push anditem
		end
		self.logVerbose "Displaying #{showupgrades and 'upgrades ' or 'only '}#{showupgrades and showdowngrades and 'and ' or ''}#{showdowngrades and 'downgrades' or 'only'}, #{@config['recipes']=='yes' and 'recipes ' or 'just '}#{@config['recipes']=='yes' and @config['binaries']=='yes' and 'and ' or ''}#{@config['binaries']=='yes' and 'binaries' or 'exclusively'}#{exl}"
		out = ""
		upgrades = downgrades = 0
		readfromcache = false
		toupdate = produceUpdatesList(showupgrades, showdowngrades, false)
		if @config['lower-limit']
			toupdate = toupdate[@config['lower-limit']..toupdate.length]
		end
		if @config['limit']
			toupdate = toupdate[0, @config['limit']]
		end

		toupdate.each {|prog|
			out+=self.progStatus prog
		}
		print ' '*Screen.width+"\015"
		tfs = 0
		out += "Total: #{toupdate.length}".center(Screen.width)+"\n" # Size: #{Gobo.smartSize(tfs)}
		print "\033]2;Freshen\007"
		puts out
	end

	def progStatus(prog)
		if @recipes[prog] and @packages[prog] and @config['recipes']=='yes' and @config['binaries']=='yes'
			newver = @recipes[prog].at(-1)
			newver = @packages[prog].at(-1) if @packages[prog].at(-1)>newver
			if @recipes[prog].at(-1)>@packages[prog].at(-1)
				recipe = true
				package = false
				newver = @recipes[prog].at(-1)
			elsif @packages[prog].at(-1)>@recipes[prog].at(-1)
				recipe = false
				package = true
				newver = @packages[prog].at(-1)
			else
				recipe = true
				package = true
				newver = @packages[prog].at(-1)
			end
		elsif @recipes[prog] and @config['recipes']=='yes'
			newver = @recipes[prog].at(-1)
			recipe = true
			package = false
		elsif @packages[prog] and @config['binaries']=='yes'
			newver = @packages[prog].at(-1)
			package = true
			recipe = false
		end
		if !@progs[prog] || !@progs[prog].set?
			upg = ' '
		elsif @progs[prog]>newver
			upg = "#{Screen.colour['red']}D#{Screen.colour['normal']}"
		elsif @progs[prog]<newver
			upg = "#{Screen.colour['cyan']}U#{Screen.colour['normal']}"
		else
			upg = ' '
		end
		progcol = Screen.colour['green']
		prs = ' '
		if recipe and package
			prs = 'X'
			progcol = Screen.colour['blue']
		elsif recipe
			prs = 'R'
			progcol = Screen.colour['green']
 		elsif package
			prs = 'B'
			progcol = Screen.colour['brown']
		end
		if !newver.nil? and newver<@progs[prog]
			progcol = Screen.colour['red']
		end
		if @progs[prog] && @progs[prog].set?
			ins = 'I'
		else
			ins = Screen.colour['green']+"N"+Screen.colour['normal']
		end
		@introducedBy[prog] = " ("+@introducedBy[prog]+")" if @introducedBy[prog]
		"[#{ins}#{upg}#{prs}] #{progcol}#{prog} #{newver}#{Screen.colour['normal']}#{@introducedBy[prog]}#{' '*(Screen.width-7-prog.length-newver.to_s.length-@progs[prog].to_s.length-@introducedBy[prog].to_s.length)}#{@progs[prog]}\n"
	end
	
	def genTree
		recipes = Hash.new
		if true||@config['recipes']=='yes'
			recipeListLines.each {|line|
				# e.g. ALSA-Utils--1.0.0rc2--recipe.tar.bz2
				parts = line.split('--')
				name = parts[0]
				ver  = parts[1]
				recipes[name] = Array.new unless recipes[name]
				recipes[name].push(Version.new(ver))
			}
			recipes.each_key {|key|
				recipes[key] = recipes[key].sort
			}
		end
		@recipes = recipes
	end
	
	def logError(msg='')
		super("#{Screen.colour['cyan']}Freshen:#{Screen.colour['normal']} #{Screen.colour['red']}#{msg}#{Screen.colour['normal']}")
	end
	def logNormal(msg='')
		super("#{Screen.colour['cyan']}Freshen:#{Screen.colour['normal']} #{msg}")
	end
	def logVerbose(msg='')
		super("#{Screen.colour['cyan']}Freshen:#{Screen.colour['normal']} #{msg}")
	end
end

=begin                                
backtrace outputs a debug-level, formatted version of $!#backtrace
=end
def backtrace
	$app.logDebug "Backtrace:\n  " + $!.backtrace.join("\n  ").gsub(/(.+?):(.+?)(:|$)/, "#{Screen.colour['brown']}\\1:#{Screen.colour['yellow']}\\2\\3#{Screen.colour['normal']}")
end

begin
	$app = Freshen.new()
	$app.start
	rescue SystemExit
		# Do nothing, this is just to stop it from giving an error message on quit
	rescue Interrupt
		$app.logError "#{Screen.colour['cyan']}Freshen:#{Screen.colour['normal']} #{Screen.colour['red']}Interrupt.#{Screen.colour['normal']}"
		backtrace
	rescue Exception
		$app.logError "#{Screen.colour['cyan']}Freshen:#{Screen.colour['normal']} #{Screen.colour['red']}Error: #{$!}#{Screen.colour['normal']} [#{$!.class}]"
		backtrace
end
