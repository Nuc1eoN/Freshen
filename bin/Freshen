#!/usr/bin/env python
# Freshen - finds and installs updates for GoboLinux systems.
# Copyright (C) 2007-2008 Michael Homer <=mwh>
# Distribution terms shown by Freshen --version.

import string, os, os.path, sys, cPickle
import time
sys.path = [os.path.abspath('.')+'/lib/python2.3'] + sys.path

from GetAvailable      import GetAvailable, getGoboVariable
from GuessLatest       import GuessLatest
from GetInstalled      import KeyInsensitiveDict
from CheckDependencies import *
from PythonUtils       import *
from TTYUtils          import *


def getTypeAbbr(type):
	return {
		'recipe': Screen.colours['green']+'R'+Screen.colours['normal'],
		'official_package': Screen.colours['brown']+'P'+Screen.colours['normal'],
		'installed': 'I',
		None: '?'
	}[type]
def puts(string):
	sys.stdout.write(string+'\n')

def showUpdates():
	System.installedPrograms()
	systemUpgrades = {'Scripts': None, 'Compile': None, 'Freshen': None}
	typeCount = {'recipe': 0, 'official_package': 0, '_binary_recipe': 0 ,'total': 0}
	for program,version,revision,type,url,intBy in System.updates():
		if typeCount['total']==0: # Only output heading the first time, if there are any.
			puts("[  ] Program%sInstalled"%(' '*(Screen.width-21)))
		typeCount[type] += 1
		typeCount['total'] += 1
		ver = Join_Version_Revision(version, revision)
		if program in systemUpgrades: systemUpgrades[program] = type
		insVer = "None"
		pcol = Screen.colours['darkgreybg']
		insVer = str(System.latestInstalled(program))
		if insVer != 'None':
			pcol = ''
		if pcol == '':
			if typeCount['total']%2==0:
				pcol=Screen.colours['blue']
			else:
				pcol=Screen.colours['cyan']
		typeAbbr = getTypeAbbr(type)
		if version.endswith('_bin') or program.endswith('-Bin'):
			typeAbbr = Screen.colours['red']+'B'+Screen.colours['normal']+typeAbbr
			typeCount['_binary_recipe'] += 1
		else: typeAbbr = ' ' + typeAbbr
		introducedByString = insVer == 'None' and '(' + intBy + ')' or ''
		normalColour = Screen.colours['normal']
		pad = " " * (Screen.width-len(program)-len(ver)-len(insVer)-len(introducedByString)-7)
		out = "[%s] %s%s %s %s%s%s%s"%(typeAbbr, pcol, program, ver, introducedByString, pad, insVer, normalColour)
		puts(out)
	puts("%(recipe)i recipes, %(_binary_recipe)i binary recipes, %(official_package)i packages, %(total)i total"%typeCount)
	for prog in ('Scripts', 'Compile', 'Freshen'):
		if systemUpgrades[prog]:
			cmd = systemUpgrades[prog] == 'recipe' and 'Compile' or 'InstallPackage'
			Log_Error("An upgrade to %s is available. It is strongly recommended that you upgrade immediately with `%s %s`."%(prog, cmd, prog), 'Freshen')

# Parse the value of a shell variable out of a file (recipe), performing variable substitutions.
def parse_var(string, variableDefinitions=None):
	from string import Template
	if not hasattr(parse_var, 'definitions'):
		parse_var.definitions = {
			'goboPrograms': getGoboVariable('goboPrograms'),
			'goboShared':   getGoboVariable('goboShared'),
			'goboSettings': getGoboVariable('goboSettings'),
			'goboLinks':    getGoboVariable('goboLinks'),
		}
	if not variableDefinitions:
		variableDefinitions = {}
	variableDefinitions.update(parse_var.variableDefinitions)
	for variable in variableDefinitions:
		t = Template(variableDefinitions[variable])
		variableDefinitions[variable] = t.safe_substitute(variableDefinitions)
	t = Template(string.split('=', 2)[1])
	return t.safe_substitute(variableDefinitions)

# TODO: Handle failed installations
def installUpdates():
	i=0
	postMessages = []
	programs = set()
	for program,version,revision,type,url,intBy in System.updates():
		i+=1
		programs.add(program)
		ver = Join_Version_Revision(version, revision)
		Log_Normal("Installing update %i: %s %s..."%(i, program, ver), 'Freshen')
		if type == 'recipe':
			os.system("Compile -G -U -D -b %s"%(url))
			rec = os.popen('GetRecipe %s %s'%(program, ver)).readline().strip()+'/Recipe'
			if os.path.exists(rec):
				file = open(rec, 'r')
				for line in file:
					if line.startswith('post_install_message='):
						postMessages.append((program, parse_var(line, {'target': '$goboPrograms/%s/%s' % (program,version)})))
						break
				file.close()
		elif type == 'official_package':
			os.system("InstallPackage -k -U -s keep -b -D -u keep %s"%(url))
		else:
			Log_Error("Unknown action '%s'!"%(type))
			exit()
	for program,version,revision,type,url,intBy in ulist:
		if os.system("UpdateSettings -c" + program):
			os.system("UpdateSettings -a "+program)
	if postMessages:
		Log_Normal("Some of the installed programs requested post-install messages be displayed:")
		for program,message in postMessages:
			puts("%s: %s"%(program, message))
	System.clearCache()

def showVersion():
	puts("""
Freshen %(major)i.%(minor)i.%(revision)i%(prerelease)s
(C) 2007-2008 Michael Homer <=mwh>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""%(System.version))

def showHelp():
	puts("""
Checks for updated GoboLinux recipes and packages.

Usage: Freshen [<opts>] [<list>]

Options:
   --exclude, -x <xlist>
      Exclude <xlist> from updating. Does not exclude other programs depending
      on <xlist>.
   --force-cache, -c
      Force using cached updates data, rather than recalculating them.
   --no-cache, -C
      Force regenerating updates data, rather than reading from cache.
   --thorough
      Include deep updates to revisions and up-to-date dependencies.
   -U
      Install updates.
   --version
      Display version and copyright information.
Notes:
Run with no arguments, Freshen outputs a list of updates in the form:
[%(red)sB%(green)sR%(normal)s] Foo 2.0                                                                 1.0
The mnemonics mean:
 %(green)sR%(normal)s Recipe will be used                    %(brown)sNew program%(normal)s
 %(brown)sP%(normal)s Package will be used                   Other colours are for readability only
 %(red)sB%(normal)s Binary recipe

If <list> is provided, Freshen examines only the programs in it and their dependencies. If <list> is not provided, Freshen will examine all installed programs.

Examples:
   Freshen -x LibFoo LibBar -U Baz Quux
"""%Screen.colours)

class FreshenArgParser:
	def __init__(self):
		self.fetched = False
	def fetch(self):
		if self.fetched:
			return
		self.fetched = True
		self.skipSet = set()
		self.toExamine = set()
		self.mode = 'updating'
		self.noCache = False
		self.forceCache = False
		self.action = showUpdates
		self.limit = None
		catching = self.toExamine
		singleCatch = ''
		for arg in sys.argv[1:]:
			if arg=='-x' or arg=='--exclude':
				catching = self.skipSet
			else:
				reset = True # Reset catching to toExamine if we hit a non-list option
				if arg=='--thorough':
					self.mode = 'all'
				elif arg=='--no-cache' or arg=='-C':
					self.noCache = True
				elif arg=='--force-cache' or arg=='-c':
					self.forceCache = True
				elif arg=='--limit' or arg=='-l':
					singleCatch = 'limit'
				elif arg=='-U':
					self.action = installUpdates
				elif arg=='--help':
					self.action=showHelp
				elif arg=='--version':
					self.action=showVersion
				elif arg=='--no-colour':
					for c in Screen.colours:
						Screen.colours[c] = ''
				elif arg=='--':
					catching = toExamine
				elif singleCatch:
					self.__dict__[singleCatch] = arg
					singleCatch = ''
				elif arg[0:2]=='--':
					Log_Error("Invalid argument "+arg, 'Freshen')
					exit()
				else:
					catching.add(arg)
					reset = False
				if reset: catching = self.toExamine
		self.progString = ', '.join(self.toExamine)
		self.toExamine = frozenset(self.toExamine)
		self.skipSet = frozenset(self.skipSet)
		self.cacheDataID = hash(self.toExamine)
	def __getattr__(self, name):
		self.fetch()
		if 'examineSet' == name:
			if self.toExamine:
				return self.toExamine
			else:
				if self.mode == 'all':
					self.toExamine = frozenset(set(System.installedPrograms().keys()))
				else:
					self.toExamine = frozenset(prog for prog in System.installedPrograms().keys() if System.updateAvailable(prog))
				#
				self.cacheDataID = hash(self.toExamine)
				self.progString = 'all'
				return self.toExamine
		return self.__dict__[name]

class System:
	args = FreshenArgParser()
	installedProgramsCache = {}
	currentVersionCache = {}
	latestCache = None
	cacheDataFormatVersion = 1
	version = {'major': 3, 'minor': 0, 'revision': 0, 'prerelease': 'alpha'}
	@classmethod
	def installedPrograms(self):
		if self.installedProgramsCache:
			return self.installedProgramsCache
		else:
			global global_available_packages_cache
			if not global_available_packages_cache: self.fetchAvailables()
			installed = global_available_packages_cache['installed']['programs']
			# Generator: tuple (program, versionlist)
			# List comprehension: string "version-revision" installed versions of program
			self.installedProgramsCache = KeyInsensitiveDict((prog, [v+'-'+r for v in installed[prog] for r in installed[prog][v]]) for prog in installed)
			return self.installedProgramsCache
			
	@classmethod
	def latestInstalled(self, program):
		if not self.currentVersionCache:
			self.currentVersionCache = KeyInsensitiveDict()
		if program in self.currentVersionCache:
			return self.currentVersionCache[program]
		else:
			if not self.installedProgramsCache: self.installedPrograms()
			if program in self.installedProgramsCache:
				self.currentVersionCache[program] = GuessLatest(self.installedProgramsCache[program])
			else:
				self.currentVersionCache[program] = None
			return self.currentVersionCache[program]

	@classmethod
	def latestAvailable(self, program):
		global global_available_packages_cache
		if not global_available_packages_cache: self.fetchAvailables()
		if not self.latestCache:
			self.latestCache = KeyInsensitiveDict()
		if program in self.latestCache:
			return self.latestCache[program]
		latest = None
		recipes = global_available_packages_cache['recipe']['programs']
		if program in recipes:
			lver = GuessLatest(recipes[program].keys())
			lrev = GuessLatest(recipes[program][lver].keys())
			latest = Join_Version_Revision(lver, lrev)
		packages = global_available_packages_cache['official_package']['programs']
		if program in packages:
			lver = GuessLatest(packages[program].keys())
			lrev = GuessLatest(packages[program][lver].keys())
			if not latest: latest = Join_Version_Revision(lver, lrev)
			else: latest = GuessLatest([latest, Join_Version_Revision(lver, lrev)])
		return latest
	
	@classmethod
	def updateAvailable(self, program):
		latestInstalled = System.latestInstalled(program)
		latestAvailable = System.latestAvailable(program)
		if not latestInstalled: return True
		if not latestAvailable: return False
		return (GuessLatest([latestInstalled, latestAvailable]) != latestInstalled)
		
	@classmethod
	def updates(self):
		types = ['official_package', 'recipe']
		toExamine,mode,skipSet = System.args.examineSet,System.args.mode,System.args.skipSet
		yieldCount = 0
		if System.args.limit: limit = int(System.args.limit)
		else: limit = None
		# Load from cache, and yield any programs in there up to the limit
		programList,considered,listComplete = self.loadCache()
		pb = ProgressBar(len(toExamine), limit)
		for program,version,revision,type,url,intBy in programList:
			if yieldCount == limit: return # Satisfied request from cache, so terminate.
			if not self.skip(program, version, revision):
				yieldCount+=1
				pb.inc2()
				yield (program,version,revision,type,url,intBy)
		if listComplete:
			pb.clear()
			return
		for examinedProgram in toExamine:
			pb.inc() # Increment examined program bar
			if examinedProgram in considered: continue
			if limit and pb.value2 >= limit:
				self.saveCache(programList, considered, False)
				raise StopIteration
			if self.skip(examinedProgram, None, None): continue
			# Process actual results from here
			orderedRules,orderedMatches = CheckDependencies(examinedProgram, acceptable_types=types, mode=mode, recursive=True)
			for program,version,revision,type,url in [upd for upd in orderedMatches if upd[0] not in considered]:
				considered.add(program)
				if type != 'installed' and type is not None:
					ver = Join_Version_Revision(version, revision)
					insVer = self.latestInstalled(program)
					if not insVer or (insVer != ver and GuessLatest([ver, insVer]) == ver):
						update = (program,version,revision,type,url,examinedProgram) # Add "introduced by" examinedProgram to tuple.
						programList.append(update) # Keep a list for caching's sake
						# Only yield when under the limit, but continue the loop for caching'update sake.
						if not self.skip(program,version,revision) and (not limit or yieldCount < limit):
							yieldCount+=1
							if limit and yieldCount>=limit: pb.clear()
							yield update
							pb.inc2() # Increment yielded update bar
		self.saveCache(programList, considered, True)
		pb.clear()
	
	@classmethod
	def skip(self, program,version,revision):
		if program in self.args.skipSet: return True
		# Skip e.g. KDE-* with -x KDE
		spl = program.split('-')
		if len(spl)>1 and spl[0] in self.args.skipSet: return True
		return False
	
	@classmethod
	def cacheFile(self):
		cacheDir = os.environ.get('HOME') + '/.Settings/freshen_cache'
		if not os.path.exists(cacheDir):
			os.makedirs(cacheDir)
		return "%s/%s-%u"%(cacheDir, System.args.mode, System.args.cacheDataID)
		
	@classmethod
	def saveCache(self, programList, considered, listComplete):
		f = open(self.cacheFile(), 'w')
		cPickle.dump(System.cacheDataFormatVersion, f, protocol = cPickle.HIGHEST_PROTOCOL)
		cPickle.dump(programList, f, protocol = cPickle.HIGHEST_PROTOCOL)
		cPickle.dump(considered, f, protocol = cPickle.HIGHEST_PROTOCOL)
		cPickle.dump(listComplete, f, protocol = cPickle.HIGHEST_PROTOCOL)
		f.close()
		directory = os.environ.get('HOME') + '/.Settings/freshen_cache/'
		# Delete expired cache files
		for fn in os.listdir(directory):
			if time.time()-os.path.getmtime(directory+'/'+fn)>1800:
				os.unlink(directory+'/'+fn)
		
	@classmethod
	def loadCache(self):
		cacheFile = self.cacheFile()
		if System.args.forceCache or not System.args.noCache and os.path.exists(cacheFile) and os.path.exists(cacheFile) and time.time()-os.path.getmtime(cacheFile)<1800:
			Log_Normal("Loading updates list from cache... (use -C to disable)", 'Freshen')
			f = open(cacheFile, 'r')
			format = cPickle.load(f)
			if format != System.cacheDataFormatVersion:
				return ([], set(), False)
			progList = cPickle.load(f)
			considered = cPickle.load(f)
			listComplete = cPickle.load(f)
			f.close()
			return (progList, considered, listComplete)
		return ([], set(), False)
	
	@classmethod
	def fetchAvailables(self):
		global global_available_packages_cache
		cacheFile = os.environ.get('HOME') + '/.Settings/freshen_cache/availables.cache'
		if global_available_packages_cache: return
		elif not System.args.noCache and os.path.exists(cacheFile) and (System.args.forceCache or time.time()-os.path.getmtime(cacheFile)<1800):
			f = open(cacheFile, 'r')
			global_available_packages_cache = cPickle.load(f)
			f.close()
		else:
			consoleProgressHook.endString = '\015'
			global_available_packages_cache = 	GetAvailable(types=['installed','local_package','official_package', 'recipe', 'contrib_package', 'tracked'], hook=consoleProgressHook)
			f = open(cacheFile, 'w')
			cPickle.dump(global_available_packages_cache, f, protocol = cPickle.HIGHEST_PROTOCOL)
			f.close()
	
	@classmethod
	def clearCache(self):
		cacheFile = System.cacheFile()
		for cacheFile in (System.cacheFile(), os.environ.get('HOME')+'/.Settings/freshen_cache/availables.cache'):
			if os.path.exists(cacheFile):
				os.unlink(cacheFile)

try:
	# Execute the defined action
	System.args.action()
except KeyboardInterrupt:
	pass
finally: # Clear title on exit
	sys.stderr.write("\033]2;\007");
