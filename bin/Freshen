#!/usr/bin/python
# Copyright (C) 2008 Michael Homer <=mwh>
# Portions copyright (C) 2004-2007 Andre Detsch <detsch at gobolinux.org>
# Released under the GNU GPL.

import string, os, os.path, sys, cPickle
import time
sys.path = [os.path.abspath('.')+'/lib/python2.3'] + sys.path

from GetAvailable      import GetAvailable, getGoboVariable
from GuessLatest       import GuessLatest
from GetInstalled      import KeyInsensitiveDict
from CheckDependencies import *
from TTYUtils import *


def getTypeAbbr(type):
	return {
		'recipe': Screen.colours['green']+'R'+Screen.colours['normal'],
		'official_package': Screen.colours['red']+'P'+Screen.colours['normal'],
		'installed': 'I',
		None: '?'
	}[type]

def showUpdates():
	i=0
	System.installedPrograms()
	systemUpgrades = {'Scripts': None, 'Compile': None, 'Freshen': None}
	print "[ ] Program                                                            Installed"
	for program,version,revision,ptype,url in System.updates():
		ver = Join_Version_Revision(version, revision)
		if program in systemUpgrades: systemUpgrades[program] = ptype
		insVer = "None"
		pcol = Screen.colours['brown']
		insVer = str(System.latestInstalled(program))
		if insVer != 'None':
			pcol = ''
		i+=1
		if pcol == '':
			if i%2==0:
				pcol=Screen.colours['blue']
			else:
				pcol=Screen.colours['cyan']
		tabbr = getTypeAbbr(ptype)
		ibstring = ''
		ncol = Screen.colours['normal']
		pad = " " * (Screen.width-len(program)-len(ver)-len(insVer)-6)
		out = "[%s] %s%s %s %s%s%s%s"%(tabbr, pcol, program, ver, ibstring, pad, insVer, ncol)
		print out
	for prog in ('Scripts', 'Compile', 'Freshen'):
		if systemUpgrades[prog]:
			cmd = systemUpgrades[prog] == 'recipe' and 'Compile' or 'InstallPackage'
			System.notice("An upgrade to %s is available. It is %sstrongly%s%s recommended that you upgrade immediately with `%s %s`."%(prog, Screen.colours['redbg'], Screen.colours['normal'], Screen.colours['red'], cmd, prog))

# Parse the value of a shell variable out of a file (recipe), performing variable substitutions.
def parse_var(s, definitions=None):
	from string import Template
	if not hasattr(shellparse, 'definitions'):
		shellparse.definitions = {
			'goboPrograms': getGoboVariable('goboPrograms'),
			'goboShared':   getGoboVariable('goboShared'),
			'goboSettings': getGoboVariable('goboSettings'),
			'goboLinks':    getGoboVariable('goboLinks'),
		}
	if not definitions:
		definitions = {}
	definitions.update(shellparse.definitions)
	for k in definitions:
		t = Template(definitions[k])
		t.safe_substitute(definitions)
	t = Template(s.split('=', 2)[1:-1])
	return t.safe_substitute(definitions)
	
# TODO: Handle failed installations
def installUpdates():
	i=0
	postMessages = {}
	programs = set()
	for program,version,revision,ptype,url in System.updates():
		i+=1
		programs.add(program)
		ver = Join_Version_Revision(version, revision)
		System.message("Freshen: Installing update %i/%i: %s %s..."%(i, len(ulist), program, ver))
		if ptype == 'recipe':
			os.system("Compile -G -U -D -b %s"%(url))
			rec = os.popen('GetRecipe %s %s'%(program, ver)).readline().strip()+'/Recipe'
			if os.path.exists(rec):
				f = open(rec, 'r')
				for x in f:
					if x.startswith('post_install_message='):
						postMessages[program] = parse_var(x, {'target': '$goboPrograms/%s/%s' % (program,version)})
						break
				f.close()
		elif ptype == 'official_package':
			os.system("InstallPackage -k -U -s keep -b -D -u keep %s"%(url))
		else:
			print "Unknown action!"
			exit()
	for program,version,revision,ptype,url in ulist:
		if os.system("UpdateSettings -c" + program):
			os.system("UpdateSettings -a "+program)
	if postMessages:
		print "Some of the installed programs requested post-install messages be displayed:"
		for p,v in postMessages.iteritems():
			print "%s: %s"%(p, v)

def showHelp():
	print """
Checks for updated GoboLinux recipes and packages.

Usage: Freshen [<opts>] [<list>]

Options:
   --exclude, -x <xlist>
      Exclude <xlist> from updating. Does not exclude other programs depending
      on <xlist>.
   --force-cache, -c
      Force using cached updates data, rather than recalculating them.
   --no-cache, -C
      Force regenerating updates data, rather than reading from cache.
   --thorough
      Include deep updates to revisions and up-to-date dependencies.
   -U
      Install updates.

Notes:
Run with no arguments, Freshen outputs a list of updates in the form:
[%sR%s] Foo 2.0                                                                  1.0
The mnemonics mean:
 %sR%s Recipe will be used                    %sNew program%s
 %sP%s Package will be used                   Other colours are for readability only

If <list> is provided, Freshen examines only the programs in it and their dependencies. If <list> is not provided, Freshen will examine all installed programs.

Examples:
   Freshen -x LibFoo LibBar -U Baz Quux
"""%(Screen.colours['green'], Screen.colours['normal'], Screen.colours['green'], Screen.colours['normal'], Screen.colours['brown'], Screen.colours['normal'], Screen.colours['brown'], Screen.colours['normal'])

class FreshenArgParser:
	def __init__(self):
		self.fetched = False
	def fetch(self):
		if self.fetched:
			return
		self.fetched = True
		self.skipList = []
		self.elist = []
		self.mode = 'updating'
		self.noCache = False
		self.forceCache = False
		self.action = showUpdates
		self.limit = None
		catching = self.elist
		singleCatch = ''
		for li in sys.argv[1:]:
			if li=='-x' or li=='--exclude':
				catching = self.skipList
			else:
				reset = True # Reset catching to elist if we hit a non-list option
				if li=='--thorough':
					self.mode = 'all'
				elif li=='--no-cache' or li=='-C':
					self.noCache = True
				elif li=='--force-cache' or li=='-c':
					self.forceCache = True
				elif li=='--limit' or li=='-l':
					singleCatch = 'limit'
				elif li=='-U':
					self.action = installUpdates
				elif li=='--help':
					self.action=showHelp
				elif li=='--no-colour':
					for c in Screen.colours:
						Screen.colours[c] = ''
				elif li=='--':
					catching = elist
				elif singleCatch:
					self.__dict__[singleCatch] = li
					singleCatch = ''
				elif li[0:2]=='--':
					System.error("Invalid argument "+li)
					exit()
				else:
					catching.append(li)
					reset = False
				if reset: catching = self.elist
		self.progString = ', '.join(self.elist)
		self.clProgs = '-'.join(self.elist)
	def __getattr__(self, name):
		self.fetch()
		if 'examineList' == name:
			if self.elist:
				return self.elist
			else:
				self.elist = System.installedPrograms().keys()
				self.progString = 'all'
				return self.elist
		return self.__dict__[name]

class System:
	args = FreshenArgParser()
	ipcache = {}
	vcache = {}
	@classmethod
	def installedPrograms(self):
		if self.ipcache:
			return self.ipcache
		else:
			installed = GetAvailable(['installed'], hook=consoleProgressHook, accessWeb=True)['installed']['programs']
			for prog in installed.keys():
				versions = installed[prog]
				self.ipcache[prog] = []
				for v,revisions in versions.iteritems():
					for r in revisions.keys():
						self.ipcache[prog].append(v+'-'+r)
			return self.ipcache
			
	@classmethod
	def latestInstalled(self, p):
		if not self.vcache:
			self.vcache = {}
		if p in self.vcache:
			return self.vcache[p]
		else:
			if not self.ipcache: self.installedPrograms()
			if p in self.ipcache:
				self.vcache[p] = GuessLatest(self.ipcache[p])
			else:
				self.vcache[p] = None
			return self.vcache[p]
	
	@classmethod
	def updates(self):
		types = ['official_package', 'recipe']
		elist,mode,skipList = System.args.examineList,System.args.mode,set(System.args.skipList)
		i = yc = 0
		if System.args.limit: limit = int(System.args.limit)
		else: limit = None
		# Load from cache, and yield any programs in there up to the limit
		plist,considered = self.loadCache()
		pb = ProgressBar(len(elist), limit)
		for s in plist:
			if yc == limit: return # Satisfied request from cache, so terminate.
			if s[0] not in skipList:
				yc+=1
				pb.inc2()
				yield s
		for p in elist:
			i+=1
			pb.inc()
			if p in considered: continue
			if limit and pb.value2 >= limit:
				self.saveCache(plist, considered)
				raise StopIteration
			# Process actual results from here
			deps,sols = CheckDependencies(p, acceptable_types=types, mode=mode, recursive=True)
			for s in filter(lambda s: s[0] not in considered, sols):
				considered.add(s[0])
				if s[3] != 'installed' and s[3] is not None:
					ver = Join_Version_Revision(s[1], s[2])
					insVer = self.latestInstalled(s[0])
					if not insVer or (insVer != ver and GuessLatest([ver, insVer]) == ver):
						plist.append(s)
						# Only yield when under the limit, but continue the loop for caching's sake.
						if s[0] not in skipList and (not limit or yc < limit):
							yc+=1
							yield s
							pb.inc2()
		self.saveCache(plist, considered)
		pb.clear()
	
	@classmethod
	def cacheFile(self):
		cacheDir = os.environ.get('HOME') + '/.Settings/freshen_cache/'
		if not os.path.exists(cacheDir):
			os.makedirs(cacheDir)
		return cacheDir+System.args.mode+'-'+System.args.clProgs
		
	@classmethod
	def saveCache(self, plist, considered):
		f = open(self.cacheFile(), 'w')
		cPickle.dump(plist, f, protocol = cPickle.HIGHEST_PROTOCOL)
		cPickle.dump(considered, f, protocol = cPickle.HIGHEST_PROTOCOL)
		f.close()
		
	@classmethod
	def loadCache(self):
		cacheFile = self.cacheFile()
		if System.args.forceCache or not System.args.noCache and os.path.exists(cacheFile) and os.path.exists(cacheFile) and time.time()-os.path.getmtime(cacheFile)<600:
			System.message("Loading program list from cache... (use -C to disable)")
			f = open(cacheFile, 'r')
			progList = cPickle.load(f)
			considered = cPickle.load(f)
			f.close()
			return (progList, considered)
		return ([], set())
		
	@classmethod
	def message(self, s):
		sys.stderr.write("\033]2;"+s+"\007Freshen: "+s+"\n")
	@classmethod
	def notice(self, s):
		sys.stderr.write("%s%s%s\n"%(Screen.colours['red'], s, Screen.colours['normal']))
	@classmethod
	def error(self, s):
		sys.stderr.write("\033]2;\007%sFreshen: %s%s\n"%(Screen.colours['red'], s, Screen.colours['normal']))

try:
	# Execute the defined action
	System.args.action()
except KeyboardInterrupt:
	pass
finally:
	sys.stderr.write("\033]2;\007");