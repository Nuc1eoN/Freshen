#!/usr/bin/ruby

# Add libraries
#This is for the global libraries
$: << "/System/Links/Libraries/ruby/site_ruby/1.8/"
#And this is for mine
dirname = File.dirname(`readlink -f #{$0}`)
$: << File.expand_path("#{dirname}/../lib/")

require 'screen'
require 'version'
require 'gobo'
require 'gobo/parseconfig'
require 'merge'
require 'progressbar'

class Freshen < GoboApplication
	def initialize()
		super()
		@dirname = File.dirname(`readlink -f #{$0}`)
		@progs = nil
		@recipes = nil
		@packages = nil
		@config = GoboParseConfig.new(File.expand_path("#{@dirname}/../../Settings/Freshen") + "/Freshen.conf")
		if @config['verbosity']=='error'
			@logLevel = 10
		elsif @config['verbosity']=='quiet'
			@logLevel = 20
		elsif @config['verbosity']=='normal'
			@logLevel = 30
		elsif @config['verbosity']=='verbose'
			@logLevel = 40
		elsif @config['verbosity']=='debug'
			@logLevel = 50
		end
		['recipeCacheTimeout','downloadTimeout','programsCacheTimeout'].each {|x|
			if match=@config[x].match(/([0-9.]+)([smhdw])/)
				match[2]=='s' and mul = 1
				match[2]=='m' and mul = 60
				match[2]=='h' and mul = 3600
				match[2]=='d' and mul = 86400
				match[2]=='w' and mul = 604800
				@config[x] = match[1].to_i*mul
			end
		}
		addOptionBoolean("upgrades", ["-n"], "Include upgrades#{@config['showUpgrades']=='yes' and ' [default]' or ''}")
		addOptionBoolean("no-upgrades", ["-N"], "Do not include upgrades#{@config['showUpgrades']=='no' and ' [default]' or ''}")
		addOptionBoolean("downgrades", ["-d"], "Include downgrades#{@config['showDowngrades']=='yes' and ' [default]' or ''}")
		addOptionBoolean("no-downgrades", ["-D"], "Do not include downgrades.#{@config['showDowngrades']=='no' and ' [default]' or ''}")
		addOptionBoolean("no-cache", ["-C"], "Do not use cached data for /Programs")
		addOptionBoolean("cache-only", ["-c"], "Update caches only")
		addOptionBoolean("binaries", ["-b"], "Include binary packages#{@config['binaries']=='yes' and ' [default]' or ''}")
		addOptionBoolean("no-binaries", ["-B"], "Do not include binary packages#{@config['binaries']=='no' and ' [default]' or ''}")
		addOptionBoolean("recipes", ["-r"], "Include recipes#{@config['recipes']=='yes' and ' [default]' or ''}")
		addOptionBoolean("no-recipes", ["-R"], "Do not include recipes#{@config['recipes']=='no' and ' [default]' or ''}")
		addOptionEntry("netmode", [], "Set netMode to (online|offline|always)")
		addOptionBoolean("upgrade", ["-u"], "Upgrade <list>")
		addOptionBoolean("upgrade-system", ["-U"], "Upgrade all available recipes except <list>")
		addOptionEntry("info", ["-i"], "Get information on <programme>")
		addOptionEntry("compileroot", [], "Override the Compile base dir")
      self.description = "Checks for updated GoboLinux recipes and packages"
      self.credits     = "By Michael Homer <dufus@wotfun.com>"
      self.usage       = "[<opts>]"
      self.example     = "-D"
      self.helpOnNoArguments = false
      @version         = "2.0"
      self.notes = <<END_OF_NOTES
Run with no arguments, Freshen outputs a list of updates in the form:
[I#{Screen.colour['cyan']}U#{Screen.colour['normal']}X] #{Screen.colour['red']}Foo 2.0#{Screen.colour['normal']}                                                                1.0
The mnemonics mean:                Colour code:
 I Installed                       #{Screen.colour['green']}Recipe        #{Screen.colour['brown']}Binary#{Screen.colour['normal']}
 #{Screen.colour['cyan']}U#{Screen.colour['normal']} Upgrade                         #{Screen.colour['blue']}Recipe+Binary #{Screen.colour['red']}Downgrade#{Screen.colour['normal']}
 #{Screen.colour['red']}D#{Screen.colour['normal']} Downgrade
 R Recipe available
 B Binary available
 X Recipe and binary available
END_OF_NOTES
	end
	def run
		if options('upgrades')
			@config['showUpgrades'] = 'yes'
		elsif options('no-upgrades')
			@config['showUpgrades'] = 'no'
		end
		if options('binaries')
			@config['binaries'] = 'yes'
		elsif options('no-binaries')
			@config['binaries'] = 'no'
		end
		if options('recipes')
			@config['recipes'] = 'yes'
		elsif options('no-recipes')
			@config['recipes'] = 'no'
		end
		if options('downgrades')
			@config['showDowngrades'] = 'yes'
		elsif options('no-downgrades')
			@config['showDowngrades'] = 'no'
		end
		if options('netmode')
			@config['netMode'] = options('netmode')
		end
		if options('compileroot')
			@config['compileRoot'] = options('compileroot')
		end
		@compileConfig = GoboParseConfig.new("#{@config['compileRoot']}/Settings/Compile/Compile.conf")

		if options('cache-only')
			self.updateCaches
		elsif options('upgrade')
			i = 0
			ARGV.each { |prog|
				i+=1
				self.logNormal "Upgrading programme #{i}/#{ARGV.size}..."
				self.upgrade(prog)
			}
		elsif options('upgrade-system')
			self.upgradeSystem(ARGV)
		elsif options('info')
			self.info(options('info'))
		else
			self.sysStatus(@config['showUpgrades']=='yes',@config['showDowngrades']=='yes')
		end
	end
	def info(prog)
		self.genTree
		self.getProgs
		self.genPackages
		found = false
		recipe = false
		description = newver = versionstring = size = recipefile = false
		if !@recipes[prog]
			@recipes.each_key {|x|
				if x.downcase==prog.downcase
					prog = x
					found = true
					recipe = true
					break
				end
			}
			if !found
				if !@progs[prog]
					puts "#{prog} not found in @progs"
					@progs.each_key {|x|
						if x.downcase==prog.downcase
							prog = x
							found = true
							recipe = false
							break
						end
					}
				else
					found = true
					recipe = false
				end
			end
		else
			found = true
			recipe = true
		end
		if recipe
			present = false
			if @compileConfig['compileRecipeDirs'].is_a?(Array)
				@compileConfig['compileRecipeDirs'].each {|dir|
					if File.exists?("#{dir}/#{prog}/#{@recipes[prog].at(-1)}/Recipe")
						present = true
						recipefile = "#{dir}/#{prog}/#{@recipes[prog].at(-1)}/Recipe"
						break
					end
				}
			end
			if !present and @config['netMode'] == 'always'
				self.getRecipe(prog,@recipes[prog].at(-1))
				recipefile = "#{@compileConfig['getRecipeRecipeDir']}/#{prog}/#{@recipes[prog].at(-1)}/Recipe"
			end
		end
		installed = @progs[prog] if @progs[prog]
		newver = @recipes[prog].at(-1) if @recipes[prog]
		newver = @packages[prog].at(-1) if @packages[prog] and (!newver or @packages[prog].at(-1)>newver)
		if newver>installed
			nvcol = Screen.colour['red']
		else
			nvcol = Screen.colour['cyan']
		end
#		versionstring = @recipes[prog].join(" ") if @recipes[prog]
		vers = ((@recipes[prog] ? @recipes[prog] : Array.new) | (@packages[prog] ? @packages[prog] : Array.new))
		vers.each {|x|
			vers.push(vers.delete(x))
		}
		vers.sort!
		versionstring = ""
		vers.each {|ver|
			if @recipes[prog] and @packages[prog] and @recipes[prog].index(ver) and @packages[prog].index(ver)
				versionstring+= "#{Screen.colour['blue']+ver.to_s+Screen.colour['normal']} "
			elsif @recipes[prog] and @recipes[prog].index(ver)
				versionstring+= "#{Screen.colour['green']+ver.to_s+Screen.colour['normal']} "
			elsif @packages[prog] and @packages[prog].index(ver)
				versionstring+= "#{Screen.colour['brown']+ver.to_s+Screen.colour['normal']} "
			end
		}
		if recipefile and File.exists?(recipefile.sub(/Recipe$/,'')+"Resources/Description")
			description = File.open(recipefile.sub(/Recipe$/,'')+"Resources/Description").read
		end
		if recipefile
			rc = GoboParseConfig.new(recipefile)
			size = rc['file_size'].to_i if rc['file_size']
		end
		if found
			puts "  * #{Screen.colour['green']+prog+Screen.colour['normal']}"
			puts "    Description:       #{description}" if description
			puts "    Installed Version: #{Screen.colour['cyan']}#{installed}#{Screen.colour['normal']}" if installed
			puts "    Newest Version:    #{nvcol}#{newver}#{Screen.colour['normal']}" if newver
			puts "    Versions:          #{versionstring}" if versionstring
			puts "    Size:              #{Gobo.smartSize(size)}" if size
			puts "    Recipe: #{recipefile}" if recipefile
		else
			self.logError "#{prog} was not found in the recipe tree or in /Programs"
		end
	end
	def upgradeSystem(except)
		self.genTree
		self.genPackages
		self.getProgs
		rp = @recipes.clone
		rp.merge(@packages)
		pvs = Hash.new
		sz = 0
		rp.each_key {|prog|
			next unless @progs[prog] and @progs[prog].set?
			vers = rp[prog].sort
			if vers.at(-1)>@progs[prog]
				go = true
				except.each {|x|
					go = false if x.downcase==prog.downcase
				}
				if go
					pvs[prog] = vers.at(-1)
					sz+= @packsizes[prog] if @packsizes[prog]
				end
			end
		}
		i = 0
		pvs.each {|p,v|
			i+= 1
			szs = ", #{Gobo.smartSize(sz)} to go..." if sz>0
			self.logNormal "Upgrading #{i}/#{pvs.size}#{szs}..."
			self.upgrade(p)
			sz-=@packsizes[p] if @packsizes[p]
		}
	end
	def upgrade(prog)
		self.logNormal "Upgrading #{prog}..."
		self.genTree
		self.genPackages
		self.getProgs
		if !@recipes[prog] and !@packages[prog]
			found = false
			@recipes.each_key {|key|
				if key.downcase==prog.downcase
					prog = key
					found = true
					break
				end
			}
			if !found
				@packages.each_key {|key|
					if key.downcase==prog.downcase
						prog = key
						break
					end
				}
			end
		end
		newver = recipe = package = nil
		if @recipes[prog] and @packages[prog] and @config['binaries'] and @config['recipes']
			if @recipes[prog].at(-1)<@packages[prog].at(-1)
				newver = @packages[prog].at(-1)
				package = true
			elsif @recipes[prog].at(-1)>@packages[prog].at(-1)
				newver = @recipes[prog].at(-1)
				recipe = true
			else
				newver = @recipes[prog].at(-1)
				recipe = package = true
			end
		elsif @recipes[prog] and @config['recipes']
			newver = @recipes[prog].at(-1)
			recipe = true
		elsif @packages[prog] and @config['binaries']
			newver = @packages[prog].at(-1)
			package = true
		end
		prefs = @config['preference'].split(',')
		if prefs[0]=='recipe' and recipe
			self.logNormal "First preference recipe, got recipe."
			self.upgradeCompile(prog,newver)
		elsif prefs[0]=='binary' and package
			self.logNormal "First preference binary, got binary."
			self.upgradePackage(prog,newver)
		elsif prefs[1]=='recipe' and recipe
			self.logNormal "First preference binary, no binary."
			self.logNormal "Got a recipe though."
			self.upgradeCompile(prog,newver)
		elsif prefs[1]=='binary' and package
			self.logNormal "First preference recipe, no recipe."
			self.logNormal "Got a binary though."
			self.upgradePackage(prog,newver)
		else
			self.logError "Nothing matches your criteria"
		end
	end
	def upgradeCompile(prog,ver)
		self.logNormal "Feeding this off to Compile..."
		system("Compile -b #{prog} #{ver}")
	end
	def upgradePackage(prog,ver)
		gotone = false
		pfn = ""
		self.logNormal "Searching system for package..."
		@config['defaultLocalPackagesPaths'].each { |dir|
			if File.exists?("#{dir}/#{prog}--#{ver}--#{@config['arch']}.tar.bz2")
				pfn = "#{dir}/#{prog}--#{ver}--#{@config['arch']}.tar.bz2"
				gotone = true
				break
			end
		}
		if gotone
			sudo = ""
			if File.writable?("/Programs")
				sudo = "sudo -u #0 "
			end
			self.logNormal "Installing package of #{prog} #{ver} at #{pfn}"
			system("#{sudo}InstallPackage -b -D #{pfn}")
		else
			if @config['netMode']!='offline'
				self.logNormal "Downloading package to #{@config['tmpDir']}..."
				system("wget -O #{@config['tmpDir']}/#{prog}--#{ver}--#{@config['arch']}.tar.bz2 #{@config['packageRepository']}#{prog}--#{ver}--#{@config['arch']}.tar.bz2")
				self.upgradePackage(prog,ver)
			else
				self.logError "Can't install package #{prog} #{ver}: no package found and downloading disabled."
			end
		end
	end
	def getRecipe(prog,ver)
		if @config['netMode']=='ask'
			self.logError "I haven't worked out how to ask yet. Sorry."
		end
		self.logNormal "Downloading recipe for #{prog} #{ver}..."
		rf = "#{prog}--#{ver}--recipe.tar.bz2"
		system("wget -nv -O /tmp/#{rf} #{@compileConfig['getRecipeStores'][0]}/#{rf}")
		self.logNormal "Retrieved recipe..."
		pwd = Dir.pwd()
		sudo = ""
		if !File.writable?(@compileConfig['getRecipeRecipeDir']+"/#{prog}/#{ver}")
			sudo = "sudo -u #0 "
		end
		Dir.chdir(@compileConfig['getRecipeRecipeDir'])
		system("#{sudo}tar xjf /tmp/#{rf}")
		Dir.chdir(pwd)
		self.logNormal "Recipe installed."
	end
	def getProgs
		progs = Hash.new
#		pcpath = File.expand_path("#{@dirname}/../../Settings/Freshen") + "/ProgramsCache.rb"
		pcpath = "#{@config['tmpDir']}/ProgramsCache.rb"
		if File.exists?(pcpath) and File.ctime(pcpath)>Time.now-@config['programsCacheTimeout'] and !options('no-cache')
			self.logVerbose "Reading /Programs data from cache"
			eval(File.open(pcpath).read)
			@progs = progs
		else
			self.genProgs
		end
	end
	def genProgs
		self.logNormal "Generating list of installed programmes..."
#		pcpath = File.expand_path("#{@dirname}/../../Settings/Freshen") + "/ProgramsCache.rb"
		pcpath = "#{@config['tmpDir']}/ProgramsCache.rb"
		@progs = Hash.new
		pcache = "progs = {\n"
		rp = @recipes.dup
		rp.merge(@packages)
		pb = ProgressBar.new(rp.size,1)
		rp.each_key {|prog|
			curver = `readlink -f /Programs/#{prog}/Current`
			curver.match(/Current$/) and next
			curver.gsub!(/.*\/(.+?)\n/,"\\1")
			curver == "" and curver = 0
			ver = Version.new(curver)
			@progs[prog] = ver
			pcache+= "'#{prog}'=>Version.new('#{curver}'),\n"
			pb.inc
			pb.draw
		}
		print ' '*Screen.width+"\015"
		pcache+= "}"
		self.logVerbose "Saving /Programs data to cache"
		pc = File.open(pcpath,"w")
		pc.puts(pcache)
		pc.close
	end
	def genPackages
		packages = Hash.new
		if @config['binaries']=='yes'
			self.packagesListLines.each {|line|
				# e.g. ALSA-Utils--1.0.0rc2--i686.tar.bz2
				parts = line.split('--')
				name = parts[0]
				ver  = parts[1]
			if parts[2]==@config['arch']+".tar.bz2\n"
					packages[name] = Array.new unless packages[name]
					packages[name].push(Version.new(ver))
				end
			}
			pd = self.packagesDataLines.join("\n")
			@packsizes = Hash.new
			packages.each_key {|key|
				packages[key] = packages[key].sort
				safekey = key.dup
				safekey.gsub!('+',"\\\\+")
				if match = pd.match(/#{safekey}--#{packages[key].at(-1)}--#{@config['arch']}.*?([0-9.]+)([kM])/)
					mul = 1024 if match[2]=='k'
					mul = 1048576 if match[2]=='M'
					@packsizes[key] = match[1].to_f*mul
				end
			}
		end
		@packages = packages
	end
	def packagesDataLines
		rlpath = "#{@config['tmpDir']}/BinaryPackagesData"
		if File.exists?(rlpath) and File.ctime(rlpath)>Time.now-@config['recipeCacheTimeout']
			return IO.readlines(rlpath)
		elsif File.exists?(rlpath) and @config['netMode']!='always'
			return IO.readlines(rlpath)
		elsif @config['netMode']!='always'
			return Array.new
		else
			self.logNormal "Downloading package data..."
			secs = 0
			IO.popen("wget -nv -O #{rlpath} #{@config['packageRepository']}/ 2>&1") { |pipe|
				while true
					print "\015Waiting #{@config['downloadTimeout'].to_i-secs}..."
					STDOUT.flush
					sleep 1
					secs+=1
					if secs>@config['downloadTimeout'].to_i
						self.logError "Error retrieving packages data"
						break
					end
					(print "\015#{' '*Screen.width}\015" or break) if select([pipe],nil,nil,0)
				end
			}
			return IO.readlines(rlpath)
		end
	end
	def packagesListLines
#		rlpath = File.expand_path("#{@dirname}/../../Settings/Freshen") + "/BinaryPackagesList"
		rlpath = "#{@config['tmpDir']}/BinaryPackagesList"
		if File.exists?(rlpath) and File.ctime(rlpath)>Time.now-@config['recipeCacheTimeout']
			return IO.readlines(rlpath)
		else
			if File.exists?(rlpath) and @config['netMode']=='offline'
				age =  Time.now-File.ctime(rlpath)
				age>1 and sage = "#{age.to_i} seconds"
				age>60 and sage = "#{(age/60).to_i} minutes"
				age>3600 and sage = "#{(age/3600).to_i} hours"
				age>86400 and sage = "#{(age/86400).to_i} days"
				age>604800 and sage = "#{(age/604800).to_i} weeks"
				self.logNormal "Updated BinaryPackagesList needed, current is #{sage} old... downloading is disabled, will proceed."
				return IO.readlines(rlpath)
			elsif File.exists?(rlpath)
				age =  Time.now-File.ctime(rlpath)
				age>1 and sage = "#{age.to_i} seconds"
				age>60 and sage = "#{(age/60).to_i} minutes"
				age>3600 and sage = "#{(age/3600).to_i} hours"
				age>86400 and sage = "#{(age/86400).to_i} days"
				age>604800 and sage = "#{(age/604800).to_i} weeks"
				self.logNormal "Updated BinaryPackagesList needed, current is #{sage} old... will attempt download"
			elsif @config['netMode']=='offline'
				self.logNormal "BinaryPackagesList is required to use binary packages, downloading is off. Binaries disabled."
				@config['binaries'] = 'no'
				return Array.new
			else
				self.logNormal "BinaryPackagesList required, will attempt download to #{rlpath}"
			end
		end
		secs = 0
		IO.popen("wget -nv -O #{rlpath} #{@config['packageRepository']}/BinaryPackagesList 2>&1") { |pipe|
			while true
				print "\015Waiting #{@config['downloadTimeout'].to_i-secs}..."
				STDOUT.flush
				sleep 1
				secs+=1
				if secs>@config['downloadTimeout'].to_i
					self.logError "Error retrieving packages list"
					break
				end
				(print "\015#{' '*Screen.width}\015" or break) if select([pipe],nil,nil,0)
			end
		}
		return IO.readlines(rlpath)
	end
	def updateCaches
		@config['recipeCacheTimeout'] = 0
		self.genTree
		self.genPackages
		self.genProgs
	end
	def sysStatus(showupgrades,showdowngrades)
		self.logVerbose "Displaying #{showupgrades and 'upgrades ' or 'only '}#{showupgrades and showdowngrades and 'and ' or ''}#{showdowngrades and 'downgrades' or 'only'}, #{@config['recipes']=='yes' and 'recipes ' or 'just '}#{@config['recipes']=='yes' and @config['binaries']=='yes' and 'and ' or ''}#{@config['binaries']=='yes' and 'binaries' or 'exclusively'}"
		self.genTree
		self.genPackages
		out = ""
		progs = Hash.new
		upgrades = downgrades = 0
		readfromcache = false
#		pcpath = File.expand_path("#{@dirname}/../../Settings/Freshen") + "/ProgramsCache.rb"
		pcpath = "#{@config['tmpDir']}/ProgramsCache.rb"
		if File.exists?(pcpath) and File.ctime(pcpath)>Time.now-@config['programsCacheTimeout'] and !options('no-cache')
			self.logVerbose "Reading /Programs data from cache"
			eval(File.open(pcpath).read)
			readfromcache = true
			@progs = progs
		else
			self.logNormal "Generating list of installed programmes..."
			@progs = Hash.new
		end		
		pcache = "progs = {\n"
		rp = @recipes.clone
		rp.merge(@packages)
		pb = ProgressBar.new(rp.size,1)
		rp.each_key {|prog|
			if !@progs[prog]
				curver = `readlink -f /Programs/#{prog}/Current`
				curver.match(/Current$/) and next
				curver.gsub!(/.*\/(.+?)\n/,"\\1")
				curver == "" and curver = 0
				ver = Version.new(curver)
				@progs[prog] = ver
			else
				ver = @progs[prog]
			end
			pcache+= "'#{prog}'=>Version.new('#{curver}'),\n"
			pb.inc
			pb.draw
			next unless ver.set?
			newver = nil
			if @recipes[prog]
				newver = @recipes[prog].at(-1)
			end
			if @packages[prog]
				newver = @packages[prog].at(-1) if @packages[prog].at(-1)>newver
			end
			if ver<newver and showupgrades
				out+=self.progStatus(prog)
				upgrades+=1
			elsif ver>newver and showdowngrades
				out+=self.progStatus(prog)
				downgrades+=1
			end
		}
		print ' '*Screen.width+"\015"
		tfs = 0
		out += "Upgrades: #{upgrades} Downgrades: #{downgrades} Total: #{upgrades+downgrades}".center(Screen.width)+"\n" # Size: #{Gobo.smartSize(tfs)}
		pcache+= "}"
		if !readfromcache
			self.logVerbose "Saving /Programs data to cache"
			pc = File.open(pcpath,"w")
			pc.puts(pcache)
			pc.close
		end
		puts out
	end
	def progStatus(prog)
		if @recipes[prog] and @packages[prog]
			newver = @recipes[prog].at(-1)
			newver = @packages[prog].at(-1) if @packages[prog].at(-1)>newver
			if @recipes[prog].at(-1)>@packages[prog].at(-1)
				recipe = true
				package = false
				newver = @recipes[prog].at(-1)
			elsif @packages[prog].at(-1)>@recipes[prog].at(-1)
				recipe = false
				package = true
				newver = @packages[prog].at(-1)
			else
				recipe = true
				package = true
				newver = @packages[prog].at(-1)
			end
		elsif @recipes[prog]
			newver = @recipes[prog].at(-1)
			recipe = true
			package = false
		elsif @packages[prog]
			newver = @packages[prog].at(-1)
			package = true
			recipe = false
		end
		if @progs[prog]>newver
			upg = "#{Screen.colour['red']}D#{Screen.colour['normal']}"
		elsif @progs[prog]<newver
			upg = "#{Screen.colour['cyan']}U#{Screen.colour['normal']}"
		else
			upg = ' '
		end
		progcol = Screen.colour['green']
		prs = ' '
		if recipe and package
			prs = 'X'
			progcol = Screen.colour['blue']
		elsif recipe
			prs = 'R'
			progcol = Screen.colour['green']
		elsif package
			prs = 'B'
			progcol = Screen.colour['brown']
		end
		if newver<@progs[prog]
			progcol = Screen.colour['red']
		end
		"[#{@progs[prog].set? ? 'I' : ' '}#{upg}#{prs}] #{progcol}#{prog} #{newver}#{Screen.colour['normal']}#{' '*(Screen.width-7-prog.length-newver.to_s.length-@progs[prog].to_s.length)}#{@progs[prog]}\n"
	end
	def genTree
		recipes = Hash.new
		if @config['recipes']=='yes'
			self.recipeListLines.each {|line|
				# e.g. ALSA-Utils--1.0.0rc2--recipe.tar.bz2
				parts = line.split('--')
				name = parts[0]
				ver  = parts[1]
				recipes[name] = Array.new unless recipes[name]
				recipes[name].push(Version.new(ver))
			}
			recipes.each_key {|key|
				recipes[key] = recipes[key].sort
			}
		end
		@recipes = recipes
	end
	def recipeListLines
#		rlpath = File.expand_path("#{@dirname}/../../Settings/Freshen") + "/RecipeList"
		rlpath = "#{@config['tmpDir']}/RecipeList"
		if File.exists?(rlpath) and File.ctime(rlpath)>Time.now-@config['recipeCacheTimeout']
			return IO.readlines(rlpath)
		else
			if File.exists?(rlpath) and @config['netMode']=='offline'
				age =  Time.now-File.ctime(rlpath)
				age>1 and sage = "#{age.to_i} seconds"
				age>60 and sage = "#{(age/60).to_i} minutes"
				age>3600 and sage = "#{(age/3600).to_i} hours"
				age>86400 and sage = "#{(age/86400).to_i} days"
				age>604800 and sage = "#{(age/604800).to_i} weeks"
				self.logNormal "Updated RecipeList needed, current is #{sage} old... downloading is disabled, will proceed."
			elsif File.exists?(rlpath)
				age =  Time.now-File.ctime(rlpath)
				age>1 and sage = "#{age.to_i} seconds"
				age>60 and sage = "#{(age/60).to_i} minutes"
				age>3600 and sage = "#{(age/3600).to_i} hours"
				age>86400 and sage = "#{(age/86400).to_i} days"
				age>604800 and sage = "#{(age/604800).to_i} weeks"
				self.logNormal "Updated RecipeList needed, current is #{sage} old... will attempt download"
			elsif @config['netMode']=='offline'
				self.logNormal "RecipeList required for recipe use, downloading is off. Recipes disabled."
				@config['recipes'] = 'no'
				return Array.new
			else
				self.logNormal "RecipeList required, will attempt download to #{rlpath}"
			end
		end
		secs = 0
		IO.popen("wget -nv -O #{rlpath} http://www.gobolinux.org/recipe-store/RecipeList 2>&1") { |pipe|
			while true
				print "\015Waiting #{@config['downloadTimeout'].to_i-secs}..."
				STDOUT.flush
				sleep 1
				secs+=1
				if secs>@config['downloadTimeout'].to_i
					self.logError "Error retrieving recipe list"
					break
				end
				(print "\015#{' '*Screen.width}\015" or break) if select([pipe],nil,nil,0)
			end
		}
		return IO.readlines(rlpath)
	end
	def logError(msg='')
		super("#{Screen.colour['cyan']}Freshen:#{Screen.colour['normal']} #{Screen.colour['red']}#{msg}#{Screen.colour['normal']}")
	end
	def logNormal(msg='')
		super("#{Screen.colour['cyan']}Freshen:#{Screen.colour['normal']} #{msg}")
	end
	def logVerbose(msg='')
		super("#{Screen.colour['cyan']}Freshen:#{Screen.colour['normal']} #{msg}")
	end
end

=begin                                
backtrace outputs a debug-level, formatted version of $!#backtrace
=end
def backtrace
	$app.logDebug "Backtrace:\n  " + $!.backtrace.join("\n  ").gsub(/(.+?):(.+?)(:|$)/, "#{Screen.colour['brown']}\\1:#{Screen.colour['yellow']}\\2\\3#{Screen.colour['normal']}")
end

begin
	$app = Freshen.new()
	$app.start
	rescue SystemExit
		# Do nothing, this is just to stop it from giving an error message on quit
	rescue Interrupt
		$app.logError "#{Screen.colour['cyan']}Freshen:#{Screen.colour['normal']} #{Screen.colour['red']}Interrupt.#{Screen.colour['normal']}"
		backtrace
	rescue Exception
		$app.logError "#{Screen.colour['cyan']}Freshen:#{Screen.colour['normal']} #{Screen.colour['red']}Error: #{$!}#{Screen.colour['normal']} [#{$!.class}]"
		backtrace
end     
