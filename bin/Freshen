#!/usr/bin/python
# Copyright (C) 2008 Michael Homer <=mwh>
# Portions copyright (C) 2004-2007 Andre Detsch <detsch at gobolinux.org>
# Released under the GNU GPL.

import string, os, os.path, sys, cPickle
import time
sys.path.append('./lib/python2.3')

from GetAvailable      import GetAvailable, getGoboVariable
from GuessLatest       import GuessLatest
from GuessProgramCase  import GuessProgramCase
from GetInstalled      import KeyInsensitiveDict
from GetInstalled      import GetInstalled
from CheckDependencies import *
from TTYUtils import *
from FreshenGraphUtils import *


# For debugging output
def dbprint(s):
	if False:
		sys.stderr.write(s+"\n")

def getTypeAbbr(type):
	return {
		'recipe': 'R',
		'official_package': 'P',
		'installed': 'I',
		None: '?'
	}[type]

def showUpdates(elist, graph):
	global upgradeDetails, include, cycles, installedPrograms, introducedBy
	dbprint("starting sort...")
	ls = tsort(graph, cycles=cycles)
	count = {'official_package':0,'recipe':0}
	include = {'official_package': True, 'recipe': True}
	print "[  ] Program                                                           Installed"
	for x in ls:
		upg = upgradeDetails[x]
		ver = Join_Version_Revision(upg['version'],upg['revision'])
		insVer = "None"
		if installedPrograms.has_key(x):
			insVer = GuessLatest(installedPrograms[x])
		if not installedPrograms.has_key(x) or (GuessLatest([ver, insVer]) == ver and ver != insVer):
			tabbr = getTypeAbbr(upg['type'])
			if True in [x in cyc for cyc in cycles]:
				tabbr+='C'
			else:
				tabbr+=' '
			ibstring = ''
			if x in introducedBy and len(introducedBy[x])>0:
				ibstring = '(' + ', '.join(introducedBy[x]) + ')'
			count[upg['type']]+=1
			out = "[%s] %s %s %s"%(tabbr, x, ver, ibstring)
			out = out + (" " * (Screen.width-len(out)-len(insVer))) + insVer
			if include[upg['type']]: print out
	print count
	if len(cycles)>0:
		sys.stderr.write("\nNote: the dependency graph was not acyclic. An arbitrary ordering has been used for these cycles:\n")
		for cyc in cycles:
			sys.stderr.write(" { " + ', '.join(cyc)+" }\n")

def showDepTree(elist, graph, ind='', visited=set(), parents=set()):
	global shallow
	for e in elist:
		if e not in visited:
			if e not in parents:
				print ind+e
				visited.add(e)
				if e in graph.keys():
					showDepTree(graph[e].keys(), graph, ind=ind+'  ', visited=visited, parents=parents|set([e]))
			else:
				print ind+e+" (cycle)"

goboPrograms = getGoboVariable('goboPrograms')
goboSettings = getGoboVariable('goboSettings')
goboLinks    = getGoboVariable('goboLinks')

localdirs = [ '/Mount/Cloop/Programs', '/Mount/CD-ROM/Depot/Packages/', '/Depot/Packages', os.path.abspath('.')]
types = ['official_package', 'recipe']

cycles = set()


# Generate or load from cache the total graph
# This could do with some refactoring too.
graph = {}
upgradeDetails = {}
installedPrograms = {}
introducedBy = {}
if os.path.exists('cache'):
	f = open('cache', 'r')
	graph = cPickle.load(f)
	upgradeDetails = cPickle.load(f)
	introducedBy = cPickle.load(f)
	f.close()
	installed = GetAvailable(['installed'])['installed']['programs']
	for prog in installed.keys():
		versions = installed[prog]
		installedPrograms[prog] = []
		for v,revisions in versions.iteritems():
			for r in revisions.keys():
				installedPrograms[prog].append(Join_Version_Revision(v,r))
else:
	availables = GetAvailable(['installed'] + types, localdirs, False, hook=consoleProgressHook, accessWeb=True)
	installed = availables['installed']['programs']
	for prog in installed.keys():
		versions = installed[prog]
		installedPrograms[prog] = []
		for v,revisions in versions.iteritems():
			for r in revisions.keys():
				installedPrograms[prog].append(v+'-'+r)
	print "Creating graph..."
	pset = reduce(lambda s,a: s|set(availables[a]['programs'].keys()), availables, set())
	pb = ProgressBar(len(pset))
	pb.draw()
	for p in pset:
		for t in types:
			if p in availables[t]['programs'].keys():
				vers = GuessLatest(availables[t]['programs'][p].keys())
				revision = GuessLatest(availables[t]['programs'][p][vers].keys())
				ptype = t
				url = availables[t]['programs'][p][vers][revision][0]
				break
		addProgramToGraph(graph, p, vers, revision, ptype, url, upgradeDetails, progressBar=pb, installedPrograms=installedPrograms, introducedBy=introducedBy, types=types)
		dbprint("added "+p)
	f = open('cache', 'w')
	cPickle.dump(graph, f, protocol = cPickle.HIGHEST_PROTOCOL)
	cPickle.dump(upgradeDetails, f, protocol = cPickle.HIGHEST_PROTOCOL)
	cPickle.dump(introducedBy, f, protocol = cPickle.HIGHEST_PROTOCOL)
	f.close()
	pb.clear()


# Argument parsing, for now. Allows use like `Freshen -x Qt GTK+ -s Firefox Koffice
shallow = False
elist = []
skipList = []
action = showUpdates
catching = elist
for li in sys.argv[1:]:
	if li=='-x' or li=='--exclude':
		catching = skipList
	else:
		reset = True # Reset catching to elist if we hit a non-list option
		if li=='-s' or li=='--shallow':
			shallow = True
		elif li=='--tree':
			action = showDepTree
		elif li=='--':
			catching = elist
		else:
			catching.append(li)
			reset = False
		if reset: catching = elist
		
# When no list to examine is given on the command line, default to working with all installed programs
if len(elist)==0:
	elist = installed.keys()
# The local graph deals only with the programs you can get to from programs in elist. It makes sorting
# more efficient and accurate and deptree more usable.
print "Generating local graph..."
ngraph = {}
for e in elist:
	copyGraphFromNode(graph, ngraph, e, skipList=set(skipList), installedPrograms=installedPrograms)
graph = ngraph

# Finally, perform the requested action on the list with the generated graph
action(elist, graph)
