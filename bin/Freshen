#!/usr/bin/python
# Copyright (C) 2008 Michael Homer <=mwh>
# Portions copyright (C) 2004-2007 Andre Detsch <detsch at gobolinux.org>
# Released under the GNU GPL.

import string, os, os.path, sys, cPickle
import time
sys.path = [os.path.abspath('.')+'/lib/python2.3'] + sys.path

from GetAvailable      import GetAvailable, getGoboVariable
from GuessLatest       import GuessLatest
from GetInstalled      import KeyInsensitiveDict
from CheckDependencies import *
from TTYUtils import *


def getTypeAbbr(type):
	return {
		'recipe': Screen.colours['green']+'R'+Screen.colours['normal'],
		'official_package': Screen.colours['red']+'P'+Screen.colours['normal'],
		'installed': 'I',
		None: '?'
	}[type]

def showUpdates():
	ulist = System.updatesList()
	count = {'official_package':0,'recipe':0}
	include = {'official_package': True, 'recipe': True}
	ext = []
	installedPrograms = System.installedPrograms()
	i=0
	print "[ ] Program                                                            Installed"
	for program,version,revision,ptype,url in ulist:
		ver = Join_Version_Revision(version, revision)
		insVer = "None"
		pcol = Screen.colours['brown']
		if installedPrograms.has_key(program):
			insVer = GuessLatest(installedPrograms[program])
			pcol = ''
		if not installedPrograms.has_key(program) or (GuessLatest([ver, insVer]) == ver and ver != insVer):
			i+=1
			if pcol == '':
				if i%2==0:
					pcol=Screen.colours['blue']
				else:
					pcol=Screen.colours['cyan']
			tabbr = getTypeAbbr(ptype)
			ibstring = ''
			if ptype is not None:
				count[ptype]+=1
			else:
				ext.append((program,version,revision,ptype,url))
			ncol = Screen.colours['normal']
			#if insVer != 'None': pcol = Screen.colours['green']
			pad = " " * (Screen.width-len(program)-len(ver)-len(insVer)-6)
			out = "[%s] %s%s %s %s%s%s%s"%(tabbr, pcol, program, ver, ibstring, pad, insVer, ncol)
			print out
	print count
	if ext:
		print ""
		print "Extra oddities (likely from malformed dependency files; please report):"
		for x in ext:
			print x

def parse_var(s, definitions=None):
	from string import Template
	if not hasattr(shellparse, 'definitions'):
		shellparse.definitions = {
			'goboPrograms': getGoboVariable('goboPrograms'),
			'goboShared':   getGoboVariable('goboShared'),
			'goboSettings': getGoboVariable('goboSettings'),
			'goboLinks':    getGoboVariable('goboLinks'),
		}
	if not definitions:
		definitions = {}
	definitions.update(shellparse.definitions)
	for k in definitions:
		t = Template(definitions[k])
		t.safe_substitute(definitions)
	t = Template(s.split('=', 2)[1:-1])
	return t.safe_substitute(definitions)
	
def installUpdates():
	ulist = System.updatesList()
	i=0
	postMessages = {}
	for program,version,revision,ptype,url in ulist:
		i+=1
		ver = Join_Version_Revision(version, revision)
		System.message("Freshen: Installing update %i/%i: %s %s..."%(i, len(ulist), program, ver))
		if ptype == 'recipe':
			os.system("Compile -G -U -D -b %s"%(url))
			rec = os.popen('GetRecipe %s %s'%(program, ver)).readline().strip()+'/Recipe'
			if os.path.exists(rec):
				f = open(rec, 'r')
				for x in f:
					if x.startswith('post_install_message='):
						postMessages[program] = parse_var(x, {'target': '$goboPrograms/%s/%s' % (program,version)})
						break
				f.close()
		elif ptype == 'official_package':
			os.system("InstallPackage -k -U -s keep -b -D -u keep %s"%(url))
		else:
			print "Unknown action!"
	for program,version,revision,ptype,url in ulist:
		if os.system("UpdateSettings -c" + program):
			os.system("UpdateSettings -a "+program)
	if postMessages:
		print "Some of the installed programs requested post-install messages be displayed:"
		for p,v in postMessages.iteritems():
			print "%s: %s"%(p, v)

def showHelp():
	print """
Checks for updated GoboLinux recipes and packages.

Usage: Freshen [<opts>] [<list>]

Options:
   --exclude, -x <xlist>
      Exclude <xlist> from updating. Does not exclude other programs depending
      on <xlist>.
   --force-cache, -c
      Force using cached updates data, rather than recalculating them.
   --thorough
      Include revision updates and upgrades to dependencies of current programs.
   -U
      Install updates.

Notes:
Run with no arguments, Freshen outputs a list of updates in the form:
[%sR%s] Foo 2.0                                                                  1.0
The mnemonics mean:
 %sR%s Recipe will be used                    %sNew program%s
 %sP%s Package will be used                   Other colours are for readability only

If <list> is provided, Freshen examines only the programs in it and their dependencies. If <list> is not provided, Freshen will examine all installed programs.

Examples:
   Freshen -x LibFoo LibBar -U Baz Quux
"""%(Screen.colours['green'], Screen.colours['normal'], Screen.colours['green'], Screen.colours['normal'], Screen.colours['brown'], Screen.colours['normal'], Screen.colours['brown'], Screen.colours['normal'])

class FreshenArgParser:
	def __init__(self):
		self.fetched = False
	def fetch(self):
		if self.fetched:
			return
		self.fetched = True
		self.skipList = []
		self.elist = []
		self.mode = 'updating'
		self.noCache = False
		self.forceCache = False
		self.action = showUpdates
		self.limit = None
		catching = self.elist
		singleCatch = ''
		for li in sys.argv[1:]:
			if li=='-x' or li=='--exclude':
				catching = self.skipList
			else:
				reset = True # Reset catching to elist if we hit a non-list option
				if li=='--thorough':
					self.mode = 'all'
				elif li=='--no-cache' or li=='-C':
					self.noCache = True
				elif li=='--force-cache' or li=='-c':
					self.forceCache = True
				elif li=='--limit' or li=='-l':
					singleCatch = 'limit'
				elif li=='-U':
					self.action = installUpdates
				elif li=='--help':
					self.action=showHelp
				elif li=='--no-colour':
					for c in Screen.colours:
						Screen.colours[c] = ''
				elif li=='--':
					catching = elist
				elif singleCatch:
					self.__dict__[singleCatch] = li
					singleCatch = ''
				elif li[0:2]=='--':
					System.error("Invalid argument "+li)
					exit()
				else:
					catching.append(li)
					reset = False
				if reset: catching = self.elist
		self.progString = ', '.join(self.elist)
		self.clProgs = '-'.join(self.elist)
	def __getattr__(self, name):
		self.fetch()
		if 'examineList' == name:
			if self.elist:
				return self.elist
			else:
				self.elist = System.installedPrograms().keys()
				self.progString = 'all'
				return self.elist
		return self.__dict__[name]

class System:
	args = FreshenArgParser()
	ipcache = {}
	
	@classmethod
	def installedPrograms(self):
		if self.ipcache:
			return self.ipcache
		else:
			installed = GetAvailable(['installed'], hook=consoleProgressHook, accessWeb=True)['installed']['programs']
			for prog in installed.keys():
				versions = installed[prog]
				self.ipcache[prog] = []
				for v,revisions in versions.iteritems():
					for r in revisions.keys():
						self.ipcache[prog].append(v+'-'+r)
			return self.ipcache
	
	@classmethod
	def updatesList(self):
		types = ['official_package', 'recipe']
		progList = None
		cacheDir = os.environ.get('HOME') + '/.Settings/freshen_cache/'
		if not os.path.exists(cacheDir):
			os.makedirs(cacheDir)
		cacheFile = cacheDir+System.args.mode+'-'+System.args.clProgs
		if System.args.forceCache or not System.args.noCache and os.path.exists(cacheFile) and os.path.exists(cacheFile) and time.time()-os.path.getmtime(cacheFile)<600:
			print "Loading program list from cache... (use -C to disable)"
			f = open(cacheFile, 'r')
			progList = cPickle.load(f)
			f.close()
		else:
			pb = ProgressBar(len(System.args.examineList))
			System.message("Freshen: Generating updates list for %s..."%(System.args.progString))
			pb.draw()
			progList = []
			considered = set()
			l=len(System.args.examineList)
			for p in System.args.examineList:
				if p in considered:
					pb.inc()
					continue
				deps,sols = CheckDependencies(p, acceptable_types=types, mode=System.args.mode, recursive=True)
				for s in sols:
					if s[0] not in considered:
						if s[3] != 'installed' and s[3] is not None:
							progList.append(s)
						considered.add(s[0])
				pb.inc()
			f = open(cacheFile, 'w')
			cPickle.dump(progList, f, protocol = cPickle.HIGHEST_PROTOCOL)
			f.close()
			pb.clear()
		if System.args.limit:
			progList = progList[0:int(System.args.limit)]
		return progList
		
	@classmethod
	def message(self, s):
		sys.stderr.write("\033]2;"+s+"\007Freshen: "+s+"\n")
	@classmethod
	def error(self, s):
		sys.stderr.write("\033]2;\007%sFreshen: %s%s\n"%(Screen.colours['red'], s, Screen.colours['normal']))

# Execute the defined action
System.args.action()