#!/usr/bin/env python
# Freshen - finds and installs updates for GoboLinux systems.
# Copyright (C) 2007-2008 Michael Homer <=mwh>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import string
import os
import os.path
import sys
import pickle
import time

from GetAvailable      import GetAvailable
from GuessLatest       import GuessLatest
from CheckDependencies import *
from PythonUtils       import *
from TTYUtils          import *

import Freshen
import Freshen.ArgParser as argparser


def getTypeAbbr(type):
    try:
        return getTypeAbbr.dict[type]
    except:
        getTypeAbbr.dict= {
        'recipe': Screen.colours['green']+'R'+Screen.colours['normal'],
        'official_package': (Screen.colours['brown'] + 'P'
                             + Screen.colours['normal']),
        'installed': 'I',
        None: '?'}
        return getTypeAbbr.dict[type]


def puts(string):
    sys.stdout.write(string)
    sys.stdout.write('\n')


class FreshenUI(object):
    goboPrograms = getGoboVariable('goboPrograms')
    _parse_var_definitions = {}

    def __init__(self):
        self.args = argparser.FreshenArgParser(self)
        self.limit = self.args.limit
        self.initTime = time.time()

    def error(self, message):
        Log_Error(message, 'Freshen')

    def log(self, message):
        Log_Normal(message, 'Freshen')

    def updates(self, examineSet, onExamine=None, last=False):
        req = Freshen.Request(mode=self.args.mode,
                              examineSet=examineSet,
                              skipSet=self.args.skipSet,
                              noCache=self.args.noCache,
                              forceCache=self.args.forceCache,
                              types=tuple(self.args.types),
                              noRevisions=self.args.noRevisions,
                              onExamine=onExamine,
                              last=last)
        return req

    def showUpdates(self):
        systemUpgrades = {'Scripts': None, 'Compile': None, 'Freshen': None}
        typeCount = {
            'recipe': 0,
            'official_package': 0,
            '_binary_recipe': 0,
            'total': 0}
        examineSet = self.args.examineSet
        types = tuple(self.args.types)
        if not examineSet:
            examineSet = frozenset(prog for prog in
                Freshen.installedPrograms() if
                Freshen.updateAvailable(prog, types, self.args.noRevisions))
        pb = ProgressBar(len(examineSet) + 1, self.limit, True)
        try:
            for update in self.updates(examineSet, onExamine=pb.inc):
                # Only output heading the first time, if there are any.
                if typeCount['total']==0:
                    puts("[  ] Program%sInstalled" %
                            (' ' * (Screen.width - 21)))
                # Keep track of how many of each type and in total there are
                typeCount[update.type] += 1
                typeCount['total'] += 1

                # Remember if there are updates to system tools
                if update.program in systemUpgrades:
                    systemUpgrades[update.program] = update.type

                if (update.type == 'recipe' and
                    Freshen.latestInstalled(update.program)
                    and os.path.exists(self.goboPrograms + '/'
                                        + update.program +
                                        '/Current/Resources/UseFlags')):
                    try:
                        currentFlags = set(open(
                                                self.goboPrograms +
                                                '/' + update.program +
                                                '/Current/Resources/UseFlags')
                                            .readline().split())
                    except:
                        Log_Error('Resources/UseFlags data file for '
                                    'installed %s exists but is not '
                                    'readable.' % (update.program), 'Freshen')
                else:
                    currentFlags = set()

                self.outProg(update, typeCount, currentFlags)
                pb.inc2()
                if typeCount['total'] == self.limit:
                    break
        except Freshen.CacheWarning:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            Log_Error(exc_obj.message, 'Freshen')
        finally:
            pb.clear()
            typeCount['time'] = time.time() - self.initTime
            puts("%(recipe)i recipes, %(_binary_recipe)i binary recipes, "
                    "%(official_package)i packages, %(total)i total "
                    "in %(time).2f seconds" % typeCount)
            for prog in ('Scripts', 'Compile', 'Freshen'):
                if systemUpgrades[prog]:
                    if 'recipe' == systemUpgrades[prog]:
                        cmd = 'Compile'
                    else:
                        cmd = 'InstallPackage'
                    Log_Error("An upgrade to %s is available. It is strongly "
                                "recommended that you upgrade immediately "
                                "with `%s %s`."%(prog, cmd, prog), 'Freshen')

    def outFlag(self, flag, signal, currentFlags, currentlyEnabledColour,
                currentlyDisabledColour):
        outs = None
        if not currentFlags or flag in currentFlags:
            outs = [currentlyEnabledColour]
        else:
            outs = [currentlyDisabledColour]
        outs.append(signal)
        outs.append(flag)
        outs.append(' ')
        return ''.join(outs)

    def outProg(self, update, typeCount=None, currentFlags=set()):
        (program, version, revision, type, url, intBy, enabledFlags,
            disabledFlags, activeFlags) = update.tuple9()
        ver = Join_Version_Revision(version, revision)
        # Initialise default values (uninstalled program)
        insVer = "None"
        pcol = Screen.colours['darkgreybg']

        insVer = str(Freshen.latestInstalled(program))
        if insVer != 'None':
            # Alternate colouring by row for easier reading
            if typeCount and typeCount['total'] % 2 == 0:
                pcol = Screen.colours['blue']
            else:
                pcol = Screen.colours['cyan']

        typeAbbr = getTypeAbbr(type)

        # Flag binary recipes.
        if version.endswith('_bin') or program.endswith('-Bin'):
            typeAbbr = (Screen.colours['red'] + 'B' +
                        Screen.colours['normal'] + typeAbbr)
            if typeCount:
                typeCount['_binary_recipe'] += 1
        else:
            typeAbbr = ' ' + typeAbbr

        if intBy and activeFlags:
            intBy += ': +' + ', +'.join(activeFlags)
        # Display which program has this as a dependency if it isn't
        # already installed.
        introducedByString = '(' + intBy + ')' if insVer == 'None' else ''

        # Perform output. Flags are wrapped vertically when they don't
        # fit on one line.
        # The physical length of output must be tracked, which is
        # not the same as the string length because of colour escapes.
        maxlen = Screen.width - 10
        outs = []
        outs.append("[%s] %s%s %s %s " % (typeAbbr, pcol, program, ver,
                                            introducedByString))
        # outlen will be updated, minlen is used to pad wrapped text so
        # that it lines up.
        outlen = len(program) + len(ver) + len(introducedByString) + 8
        minlen = outlen
        # Whether the installed version has been output or not.
        insverout = False
        outs.append(Screen.colours['normal'])
        for flags, sig, enCol, disCol in (
                (enabledFlags, '+', Screen.colours['green'],
                    Screen.colours['brightgreen']),
                (disabledFlags, '-', Screen.colours['red'],
                    Screen.colours['blue']),
            ):
            for flag in flags:
                # Do we need to wrap yet?
                if outlen + len(flag) + 2 >= maxlen:
                    # If this is the first line, pad and output the version.
                    if not insverout:
                        insverout = True
                        outs.append(pcol)
                        outs.append(' ' * (Screen.width - outlen -
                                            len(insVer)))
                        outs.append(insVer + Screen.colours['normal'])
                    # Initialise the padding for the next line to
                    # vertically line up with the first flag.
                    outs.append('\n')
                    outs.append(' ' * minlen)
                    outlen = minlen
                # Two characters for the space and the [+-].
                outlen += len(flag) + 2
                outs.append(self.outFlag(flag, sig, currentFlags, enCol,
                                         disCol))

        # If this is the first line of this program, print the version.
        if not insverout:
            outs.append(pcol)
            outs.append(' ' * (Screen.width-outlen-len(insVer)))
            outs.append(insVer)
        puts(''.join(outs) + Screen.colours['normal'])

    def parse_var(self, string, **variableDefinitions):
        """Parse the value of a shell variable out of a file (recipe)

        Perform variable substitutions on the value
        """
        from string import Template
        if not self._parse_var_definitions:
            self._parse_var_definitions = {
                'goboPrograms': getGoboVariable('goboPrograms'),
                'goboShared': getGoboVariable('goboShared'),
                'goboSettings': getGoboVariable('goboSettings'),
                'goboLinks': getGoboVariable('goboLinks'),
            }
        if not variableDefinitions:
            variableDefinitions = {}
        variableDefinitions.update(self._parse_var_definitions)
        for variable in variableDefinitions:
            t = Template(variableDefinitions[variable])
            variableDefinitions[variable] = \
                t.safe_substitute(variableDefinitions)
        t = Template(string.split('=', 2)[1])
        return t.safe_substitute(variableDefinitions)

    def installUpdates(self):
        i = 0
        postMessages = []
        programs = set()
        error = None
        ulist = []
        last = ('missing' == self.args.mode and not self.args.examineSet)
        types = tuple(self.args.types)
        examineSet = self.args.examineSet
        if not examineSet:
            examineSet = frozenset(prog for prog in
                Freshen.installedPrograms() if
                Freshen.updateAvailable(prog, types, self.args.noRevisions))
        try:
            updates = self.updates(examineSet, last=last)
            for u in updates:
                program, version, revision = u.program, u.version, u.revision
                i += 1
                programs.add(program)
                ver = Join_Version_Revision(version, revision)
                msg = "Installing update %i: %s %s" % (i, program, ver)
                # If the list was loaded from cache and is complete
                # (meaning the standard review-then-install method
                # was used), we know how many there are and can give
                # a better message.
                if updates.updateCount:
                    if not self.limit or self.limit > updates.updateCount:
                        self.limit = updates.updateCount
                    msg = "Installing update %i/%i: %s %s" % \
                            (i, self.limit, program, ver)
                sys.stderr.write("\033]2;%s\007" % (msg))
                Log_Normal(msg, 'Freshen')
                self.outProg(u)
                Freshen.installUpdate(u)
                ulist.append(u)
                rec = (os.popen('GetRecipe %s %s' % (program, ver))
                         .readline().strip() + '/Recipe')
                if os.path.exists(rec):
                    file = open(rec, 'r')
                    for line in file:
                        if line.startswith('post_install_message='):
                            postMessages.append((program,
                                self.parse_var(line,
                                         target='$goboPrograms/%s/%s' %
                                                (program, version))))
                            break
                    file.close()
                if i == self.limit:
                    break
        except Freshen.InstallationError:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            Log_Error("There was an error installing %s.\n"
                      "The update process will terminate.\n"
                      "Please review the errors above for details about"
                      " the problem." % (exc_obj.program))
            error = exc_obj
        except Freshen.CacheWarning:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            Log_Error(exc_obj.message, 'Freshen')
        finally:
            for upd in ulist:
                if os.system("UpdateSettings -c " + upd.program):
                    os.system("UpdateSettings -a " + upd.program)
            if postMessages:
                Log_Normal("Some of the installed programs requested "
                            "post-install messages be displayed:")
                for program, message in postMessages:
                    puts("%s: %s" % (program, message))
            Freshen.clearCache()
        if error:
            Log_Error("Because there was an error in installation, not "
                        "all of your updates may have been installed. "
                        "You should review the error messages above for "
                        "details.")
            exit(1)

    def showVersion(self):
        puts("""
Freshen %(major)i.%(minor)i.%(revision)i%(prerelease)s
(C) 2007-2008 Michael Homer <=mwh>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
""" % (Freshen.version))

    def showHelp(self):
        puts("""
Checks for updated GoboLinux recipes and packages.

Usage: Freshen <mode> [<opts>] [<list>]

Modes:
(default)
    Display list of updates.
--help
    This help text.
--install, -i
    Install <list> without upgrading any dependencies (equivalent to -U -s).
    When <list> is empty, install the updates produced by the last run of
    Freshen, to allow a simple review/install process.
--thorough
    Include deep updates to revisions and up-to-date dependencies.
--unordered
    Don't order updates or resolve dependencies.
-U
    Install updates.
--version
    Display version and copyright information.

Options:
--exclude, -x <xlist>
    Exclude <xlist> from updating. Does not exclude other programs depending
    on <xlist>.
--force-cache, -c
    Force using cached updates data, rather than recalculating them.
--limit, -l <n>
    Only include the first <n> updates.
--no-cache, -C
    Force regenerating updates data, rather than reading from cache.
--no-colour
    Remove colours from output, suitable for piping through grep.
--no-revisions
    Do not include revision-only updates [default].
--shallow, -s
    Only include <list> and necessary dependencies.
--with-revisions
    Do include revision-only updates.

Update type options:
--contrib
    Include contrib packages in update set.
--package, -p
    Include packages in update set.
--recipe, -r
    Include recipes in update set.
The order of these options sets the order of preference for each type.
If none are specified, the same as -p -r.

Notes:
Run with no arguments, Freshen outputs a list of updates in the form:
[%(red)sB%(green)sR%(normal)s] Foo 2.0                                   """
"""                              1.0
The mnemonics mean:
%(green)sR%(normal)s Recipe will be used              """
"""%(darkgreybg)sNew program%(normal)s
%(brown)sP%(normal)s Package will be used             """
"""Other colours are for readability only
%(red)sB%(normal)s Binary recipe

If <list> is provided, Freshen examines only the programs in it and their
dependencies. If <list> is not provided, Freshen will examine all installed
programs.

Examples:
Freshen -x LibFoo LibBar -U Baz Quux

Review/install pair:
    Freshen HTTPD PHP
    Freshen -i
""" % Screen.colours)


def reportBug(exc_info):
    import traceback
    import re
    ex_type, ex_obj, ex_tb = exc_info
    Log_Error("ERROR: %s.%s: %s" %
              (ex_type.__module__, ex_type.__name__, ex_obj), 'Freshen')
    sys.stderr.write('\n')
    traceback.print_exception(ex_type, ex_obj, ex_tb)
    sys.stderr.write('\n')
    sys.stderr.write('Freshen %(major)s.%(minor)s.%(revision)s%(prerelease)s'
                        % (Freshen.version))
    sys.stderr.write(' on python ' +
                        '.'.join(map(str, sys.version_info)) + '\n')
    compileVersion = 'unknown'
    scriptsVersion = 'unknown'
    try:
        compileVersion = re.search('Compile/([^/]+)/',
                                os.popen('which Compile').read()).groups()[0]
        scriptsVersion = re.search('Scripts/([^/]+)/',
                                os.popen('which UseFlags').read()).groups()[0]
    except:
        pass
    sys.stderr.write('with Scripts %s and Compile %s\n\n' %
        (scriptsVersion, compileVersion))
    sys.stderr.write('arguments: %r\n'%(sys.argv))
    sys.stderr.write(Screen.colours['red'])
    sys.stderr.write("""
*** Freshen has encountered an internal error. Please send this report to
    gobolinux-users@lists.gobolinux.org with a description of what you were
    doing when the error occurred.
""")
    sys.stderr.write(Screen.colours['normal'])
    exit(2)


def go():
    try:
        goboPrograms = getGoboVariable('goboPrograms')
        rv = list(Freshen.requiredVersions.items())
        for (prog, ver) in Freshen.requiredVersions.items():
            cur = os.readlink(goboPrograms + '/' + prog + '/Current')
            if 'svn' not in cur.lower() and \
                GuessLatest([cur, ver]) != cur:
                Log_Error("requires %s >= %s"%(prog, ver), 'Freshen')
                exit(1)
        ui = FreshenUI()
        # Execute the defined action
        if ui.args.noCache:
            Freshen.clearCache()
        ui.args.action()
        exit(0)
    except KeyboardInterrupt:
        pass
    except SystemExit:
        pass
    except IOError:
        exc_type, exc_obj, exc_tb = sys.exc_info()
        import errno
        if exc_obj.errno in (errno.EINVAL, errno.EPIPE):
            sys.stderr.write("Freshen: broken pipe")
        else:
            reportBug(sys.exc_info())
    except BaseException:
        reportBug(sys.exc_info())
    finally: # Clear title on exit
        sys.stderr.write("\033]2;\007")
