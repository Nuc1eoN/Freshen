# Copyright (C) 2007-2008 Michael Homer <=mwh>
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import
from GetAvailable import GetAvailable
from CheckDependencies import *
from UseFlags import UseFlags, potentialFlags
from Freshen.decorators import *
import pickle

version = {'major': 3, 'minor': 0, 'revision': 3, 'prerelease': ''}
requiredVersions = {
	'Scripts': '2.9.2',
	'Compile': '1.11.0',
}

_cacheDataFormatVersion = 4

@memoised
def installedPrograms():
	"""Returns a KeyInsensitiveDict of program=>[version-revisions]"""
	installed = availables()['installed']['programs']
	# Generator: tuple (program, versionlist)
	# List comprehension: string "version-revision" installed
	# versions of program
	return KeyInsensitiveDict((prog,
		[v+'-'+r for v in installed[prog] for r in installed[prog][v]])
		for prog in installed)
		
@memoised
def latestInstalled(program):
	"""Return the latest installed version-revision of program."""
	if program in installedPrograms():
		return GuessLatest(installedPrograms()[program])
	return None

@memoised
def latestAvailable(program, types=('official_package','recipe')):
	"""Return the latest available version of program (cached)."""
	latest = None
	for type in types:
		typedata = availables()[type]['programs']
		if program in typedata:
			lver = GuessLatest(typedata[program])
			lrev = GuessLatest(typedata[program][lver])
			thisver = Join_Version_Revision(lver, lrev)
			if not latest: latest = thisver
			else: latest = GuessLatest((thisver, latest))
	return latest

@memoised
def updateAvailable(program, types=('official_package', 'recipe'),
	                noRevisions=False):
	"""Whether there is a newer version of program available."""
	li = latestInstalled(program)
	la = latestAvailable(program, types=types)
	if not li: return True
	if not la: return False
	if noRevisions:
		lai,_ = Split_Version_Revision(li)
		la,_ = Split_Version_Revision(la)
	return (GuessLatest((li,la)) != li)
	

def _unordered_update(examinedProgram, req):
	packages = FindPackage(examinedProgram, types=req.types,
							availables=fetchAvailables(),
							accessWeb=False)
	newest = packages[0]
	upd = Update(newest)
	if 'recipe' == newest[3]:
		
		upd.enabledFlags = UseFlags(newest[4])
		# Calculate the disabled flags from the potentials
		# and enableds
		upd.disabledFlags = (potentialFlags(newest[4])
							- upd.enabledFlags)
	return upd

def _make_update(upd,examinedProgram):
	if 'recipe' == upd.type:
		# Flags are only really meaningful (and available) for recipes
		upd.enabledFlags = UseFlags(upd.url)
		# Calculate the disabled flags from the potentials and enableds
		upd.disabledFlags = (potentialFlags(upd.url)
							- upd.enabledFlags)
	return upd

def _program_updates_each(upd, examinedProgram, req):
	# Installed dependencies may be listed too in some modes,
	# but skip them.
	if upd.type != 'installed' and upd.type is not None:
		ver = Join_Version_Revision(upd.version, upd.revision)
		insVer = latestInstalled(upd.program)
		insVers = insVer and installedPrograms()[upd.program] or ()
		# Only updated or wholly new programs should
		# be included. However, note that in some cases
		# older versions of programs will be required.
		if not insVer or ver not in insVers:
			# Skip revision-only updates when asked
			if req.noRevisions and insVer:
				iv,_ = Split_Version_Revision(insVer)
				if version == iv:
					return None
			if not _skip(upd, req):
				return _make_update(upd, examinedProgram)
	return None

def _program_updates(examinedProgram, considered, programList, req):
	orderedRules,orderedMatches = CheckDependencies(
		examinedProgram, acceptable_types=list(req.types),
		mode=req.mode, recursive=True, availables=availables())
	thisProgramUpdates = []
	frz = frozenset()
	# Loop through the update data for dependencies that have not
	# been considered already
	for upd in (Update(upd, activeFlags=rule.get('activeflags', frz))
				for upd,rule in zip(orderedMatches,orderedRules)
				if upd[0] not in considered):
		upd.introducedBy = examinedProgram
		considered.add(upd.program)
		update = _program_updates_each(upd, examinedProgram, req)
		# Maintain updates list to yield later for caching purposes
		if update: thisProgramUpdates.append(update)
	# Save updates into the cache now, then yield them: it's
	# possible the loop will terminate before they're done.
	programList.extend(thisProgramUpdates)
	for update in thisProgramUpdates:
		yield update

def _updates_from_cache(programList, listComplete, req):
	if listComplete:
		req.updateCount = len(programList)
	for update in programList:
		# Check if this should be included, and yield it if so.
		if not _skip(update, req):
			yield update

def _updates(req, progList, considered):
	onExamine = req.onExamine
	for program in req.examineSet:
		# Call the hook if given
		if onExamine: onExamine()
		# Don't consider programs twice.
		# They could have been covered here or from the cache.
		if program in considered: continue
		if _skip(program, req): continue
		if req.mode == 'unordered':
			newest = _unordered_update(program, req)
			progList.append(newest)
			yield newest
			continue
		# Process actual results from here
		for upd in _program_updates(program, considered, progList, req):
			yield upd

def updates(req=None, mode=None, examineSet=None, skipSet=None, noCache=None,
			forceCache=None, types=None, noRevisions=None, onExamine=None,
			last=None):
	"""Generator of Freshen.Updates, in dependency-resolved order.
	
	enabledFlags and disabledFlags are the appropriate sets of
	flags this program mentions it may use in its Dependencies
	file. They are only non-empty for recipes, as the flags are
	unavailable and not useful for packages.
	"""
	if not req:
		req = FreshenRequest(mode, examineSet, skipSet, noCache, forceCache,
		                     types, noRevisions, onExamine)
	types = req.types
	noRevisions = req.noRevisions
	# Load from cache, and yield any programs from that
	if not req.examineSet:
		req.examineSet = frozenset(prog for prog in
								installedPrograms() if
								updateAvailable(prog, types, noRevisions))
	programList,considered,listComplete = _loadCache(req)
	for upd in _updates_from_cache(programList, listComplete, req):
		yield upd
	# No more updates are available, so don't bother trying
	if listComplete: return
	try:
		# Now that the cache is exhausted, go through the programs we need
		# to examine.
		for u in _updates(req, programList, considered):
			yield u
		listComplete = True
	finally:
		_saveCache(req, programList, considered, listComplete)

def installUpdate(upd):
	if upd.type == 'recipe':
		if os.system("Compile -G -U -D -b %s" % (update.url)):
			raise InstallationError(upd.program)
	elif upd.type == 'official_package' or upd.type == 'contrib_package':
		if os.system("InstallPackage -s keep -k -U -s keep -b -D "
						"--unmanaged=install %s" % (upd.url)):
			raise InstallationError(upd.program)
	else:
		raise InstallationError(None)

@memoised
def _skip(upd, req):
	"""Boolean: whether this program should be skipped
	
		Wildcard entries are included, so skipping "KDE" will also
		skip anything named KDE-*.
		"""
	if type(upd) == str: program = upd
	else: program = upd.program
	if program in req.skipSet: return True
	# Skip e.g. KDE-* with -x KDE
	spl = program.split('-')
	if len(spl) > 1 and spl[0] in req.skipSet: return True
	return False

def _cacheFile(cacheDataID, file=None):
	"""Return the filename for cached update data, given the current
		examineSet and mode."""
	cacheDir = os.environ.get('HOME') + '/.Settings/freshen_cache'
	if not os.path.exists(cacheDir):
		os.makedirs(cacheDir)
	if file:
		return "%s/%s" % (cacheDir, file)
	return "%s/%u" % (cacheDir, cacheDataID)
	

def _saveCache(req, programList, considered, listComplete):
	"""Save the update data to cache, and whether this data is complete.
		Also delete expired cache files.
		"""
	f = None
	try:
		f = open(_cacheFile(req.cacheDataID), 'w')
		pickle.dump(_cacheDataFormatVersion, f,
					protocol = pickle.HIGHEST_PROTOCOL)
		pickle.dump(programList, f, protocol = pickle.HIGHEST_PROTOCOL)
		pickle.dump(considered, f, protocol = pickle.HIGHEST_PROTOCOL)
		pickle.dump(listComplete, f, protocol = pickle.HIGHEST_PROTOCOL)
	except Exception:
		exc = sys.exc_info()
		raise CacheWarning("Unable to save update data cache. "
							"~/.Settings/freshen_cache or its\ncontents may"
							"be non-writable (%s.%s: %s)" %
							(exc[0].__module__, exc[0].__name__, exc[1]))
	finally:
		if f:
			f.close()
			lastCache = _cacheFile(req.cacheDataID, 'lastcache')
			if os.path.exists(lastCache):
				os.unlink(lastCache)
			os.link(_cacheFile(req.cacheDataID), lastCache)
	directory = os.environ.get('HOME') + '/.Settings/freshen_cache/'
	# Delete expired cache files
	for fn in os.listdir(directory):
		if time.time() - os.path.getmtime(directory + '/' + fn) > 1800:
			os.unlink(directory + '/' + fn)
	

def _loadCache(req):
	"""Load data from the cache file, if available.
	
		If data is expired, does not exist, caching is disabled,
		the cache data format is outdated, or there is some other
		error, returns an empty dataset. Result is a tuple
		(progList (list), considered (set), listComplete (boolean)).
		"""
	cacheFile = _cacheFile(req.cacheDataID)
	if req.last:
		cacheFile = _cacheFile(req.cacheDataID, 'lastcache')
	if not os.path.exists(cacheFile) or req.noCache:
		return ([], set(), False)
	if req.forceCache or (not req.noCache and
		(time.time() - os.path.getmtime(cacheFile) < 1800)):
		f = None
		try:
			f = open(cacheFile, 'r')
			format = pickle.load(f)
			if format != _cacheDataFormatVersion:
				return ([], set(), False)
			progList = pickle.load(f)
			considered = pickle.load(f)
			listComplete = pickle.load(f)
		except:
			return ([], set(), False)
		finally:
			if f: f.close()
		return (progList, considered, listComplete)
	return ([], set(), False)

@memoised
def availables():
	"""Load the available package database.
	   
	   Use cache when available or GetAvailable otherwise.
	   """
	cacheFile = _cacheFile(0, 'availables.cache')
	if (os.path.exists(cacheFile) and 
		  (time.time() - os.path.getmtime(cacheFile) < 1800)):
		try:
			f = open(cacheFile, 'r')
			return pickle.load(f)
		except:
			return fetchAvailables(forceNoCache=True)
		finally:
			f.close()
	else:
		consoleProgressHook.endString = '\015'
		availables = GetAvailable(
			types=['installed', 'local_package', 'official_package',
			'recipe', 'contrib_package', 'tracked'],
			hook=consoleProgressHook)
		try:
			f = open(cacheFile, 'w')
			pickle.dump(availables, f,
						protocol = pickle.HIGHEST_PROTOCOL)
			return availables
		except Exception:
			exc = sys.exc_info()
			raise CacheWarning("Unable to save program data cache."
								"~/.Settings/freshen_cache or its\ncontents"
								"may be non-writable (%s.%s: %s)" % 
								(exc[0].__module__, exc[0].__name__, exc[1]))
		finally:
			if f: f.close()

def clearCache():
	"""Clear the current cache files."""
	cacheDir = os.environ.get('HOME') + '/.Settings/freshen_cache'
	for cacheFile in os.listdir(cacheDir):
		try: os.unlink(cacheFile)
		except: pass

class FreshenRequest(object):
	def __init__(self, mode, examineSet, skipSet, noCache, forceCache,
		         types, noRevisions, onExamine, last):
		if not mode:
			raise Exception("Mandatory mode parameter not provided.")
		self.mode = mode
		self.examineSet = examineSet
		self.skipSet = skipSet
		self.noCache = noCache
		self.forceCache = forceCache
		self.types = tuple(types)
		self.noRevisions = noRevisions
		self.onExamine = onExamine
		self.last = last
		self.cacheDataID = hash((examineSet, tuple(types), noRevisions, mode))
		self.updateCount = 0
	
	def __iter__(self):
		return updates(self)

class InstallationError(Exception):
	program = None
	def __init__(program):
		self.program = program

class CacheWarning(UserWarning):
	pass

class Update(object):
	def __init__(self, tup, intBy=None, activeFlags=frozenset(),
				enabledFlags=frozenset(), disabledFlags=frozenset()):
		self.program,self.version,self.revision,self.type,self.url=tup
		self.introducedBy = intBy and intBy or self.program
		self.activeFlags = activeFlags
		self.enabledFlags = enabledFlags
		self.disabledFlags = disabledFlags
		self._hash = hash((self.program, self.version,
		                   self.revision, self.type))
	
	def tuple9(self):
		"""Return a nine-element tuple of update information, of the
		   same form as the previous API."""
		return (self.program, self.version,self.revision,self.type,self.url,
				self.introducedBy,self.enabledFlags,self.disabledFlags,
				self.activeFlags)
	
	def __eq__(self, other):
		if self.program != other.program: return False
		if self.version != other.version: return False
		if self.revision != other.revision: return False
		if self.type != other.type: return False
		return True
	
	def __ne__(self, other):
		return not (self == other)

	def __hash__(self):
		return self._hash
