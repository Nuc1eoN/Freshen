# Copyright (C) 2008 Michael Homer <=mwh>
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

from GetAvailable import GetAvailable
from CheckDependencies import *
from UseFlags import UseFlags, potentialFlags
import pickle

version = {'major': 3, 'minor': 0, 'revision': 0, 'prerelease': 'alpha'}

class Freshen(object):
	_installedProgramsCache = {}
	_currentVersionCache = {}
	_latestCache = None
	_cacheDataFormatVersion = 2
	
	mode = 'updating'
	noCache = False
	forceCache = False
	limit = None
	skipSet = frozenset()
	examineSet = frozenset()
	cacheDataID = 0
	progString = 'all'

	def __init__(self, mode='updating', examineSet=None, limit=None, skipSet=None, noCache=False, forceCache=False, interfaceCallbacks=dict()):
		if examineSet:
			# examineSet is an iterable, so convert it into a set.
			self.examineSet = frozenset(examineSet)
			self.progString = ', '.join(examineSet)
		elif 'all' == mode:
			# In the thorough mode, we examine every program regardless of state
			self.examineSet = frozenset(self.installedPrograms())
		else:
			# The rest of the time, only examine programs with updates available
			self.examineSet = frozenset(prog for prog in self.installedPrograms() if self.updateAvailable(prog))
		self.examineSet -= skipSet
		self.cacheDataID = hash(self.examineSet)
		
		self.mode = mode
		self.limit = limit
		if skipSet:
			self.skipSet = frozenset(skipSet)
		self.noCache = noCache
		self.forceCache = forceCache
		self.interfaceCallbacks = interfaceCallbacks

	def installedPrograms(self):
		"""Returns a (cached) KeyInsensitiveDict of installed program=>[list of version-revisions]"""
		if self._installedProgramsCache:
			return self._installedProgramsCache
		else:
			global global_available_packages_cache
			if not global_available_packages_cache: self.fetchAvailables()
			installed = global_available_packages_cache['installed']['programs']
 			# Generator: tuple (program, versionlist)
			# List comprehension: string "version-revision" installed versions of program
			self._installedProgramsCache = KeyInsensitiveDict((prog, [v+'-'+r for v in installed[prog] for r in installed[prog][v]]) for prog in installed)
			return self._installedProgramsCache
			
	
	def latestInstalled(self, program):
		"""Return the latest installed version-revision of program."""
		if not self._currentVersionCache:
			self._currentVersionCache = KeyInsensitiveDict()
		if program in self._currentVersionCache:
			return self._currentVersionCache[program]
		else:
			if not self._installedProgramsCache: self.installedPrograms()
			if program in self._installedProgramsCache:
				self._currentVersionCache[program] = GuessLatest(self._installedProgramsCache[program])
			else:
				self._currentVersionCache[program] = None
			return self._currentVersionCache[program]
	
	
	def latestAvailable(self, program):
		"""Return the latest available version of program (cached)."""
		global global_available_packages_cache
		if not global_available_packages_cache: self.fetchAvailables()
		if not self._latestCache:
			self._latestCache = KeyInsensitiveDict()
		if program in self._latestCache:
			return self._latestCache[program]
		latest = None
		recipes = global_available_packages_cache['recipe']['programs']
		if program in recipes:
			lver = GuessLatest(recipes[program])
			lrev = GuessLatest(recipes[program][lver])
			latest = Join_Version_Revision(lver, lrev)
		packages = global_available_packages_cache['official_package']['programs']
		if program in packages:
			lver = GuessLatest(packages[program])
			lrev = GuessLatest(packages[program][lver])
			if not latest: latest = Join_Version_Revision(lver, lrev)
			else: latest = GuessLatest((latest, Join_Version_Revision(lver, lrev)))
		return latest
	
	
	def updateAvailable(self, program):
		"""Boolean function: whether there is a newer version of program available than installed."""
		latestInstalled = self.latestInstalled(program)
		latestAvailable = self.latestAvailable(program)
		if not latestInstalled: return True
		if not latestAvailable: return False
		return (GuessLatest((latestInstalled, latestAvailable)) != latestInstalled)
		
	
	def updates(self, progressMeter=None):
		"""Generator of tuples of available updates, in dependency-resolved order.
		Each tuple is (program, version, revision, type, url, introducedBy, enabledFlags, disabledFlags)
		introducedBy is ONE program that has this program as a dependency, and is only useful when the program is not already installed.
		enabledFlags and disabledFlags are the appropriate sets of flags this program mentions it may use in its Dependencies file. They are only non-empty for recipes, as the flags are unavailable and not useful for packages.
		"""
		types = ['official_package', 'recipe']
		if not progressMeter:
			progressMeter = DummyProgressMeter()
		toExamine,mode,skipSet = self.examineSet, self.mode, self.skipSet
		yieldCount = 0
		if self.limit: limit = int(self.limit)
		else: limit = None
		# Load from cache, and yield any programs in there up to the limit
		programList,considered,listComplete = self.loadCache()
		
		for program,version,revision,type,url,intBy,enabledFlags,disabledFlags in programList:
			# Satisfied entire request from cache, so terminate.
			if yieldCount == limit: return
			# Otherwise, check if this should be included, and yield it if so.
			if not self.skip(program, version, revision):
				yieldCount+=1
				progressMeter.inc2()
				yield (program,version,revision,type,url,intBy,enabledFlags,disabledFlags)
		# If the cached data is complete, there's no more to yield even if we wanted to, so leave.
		if listComplete:
			progressMeter.clear()
			return
		# Now that the cache is exhausted, go through the programs we need to examine.
		for examinedProgram in toExamine:
			progressMeter.inc()
			# Don't consider programs twice. They could have been covered here or from the cache.
			if examinedProgram in considered: continue
			
			# A limited number of results was requested, and we've met it. Quit.
			if limit and progressMeter.value2 >= limit:
				self.saveCache(programList, considered, False)
				raise StopIteration
			
			if self.skip(examinedProgram, None, None): continue
			
			# Process actual results from here
			orderedRules,orderedMatches = CheckDependencies(examinedProgram, acceptable_types=types, mode=mode, recursive=True)
			# Loop through the update data for dependencies that have not been considered already
			for program,version,revision,type,url in (upd for upd in orderedMatches if upd[0] not in considered):
				considered.add(program)
				enabledFlags = frozenset()
				disabledFlags = frozenset()
				# Installed dependencies may be listed too in some modes, but skip them.
				if type != 'installed' and type is not None:
					ver = Join_Version_Revision(version, revision)
					insVer = self.latestInstalled(program)
					# Only updated or wholly new programs should be included
					if not insVer or (insVer != ver and GuessLatest((ver, insVer)) == ver):
						if 'recipe' == type:
							# Flags are only really meaningful (and available) for recipes
							enabledFlags = UseFlags(url)
							# Calculate the disabled flags from the potentials and enableds
							disabledFlags = potentialFlags(url) - enabledFlags
						
						update = (program,version,revision,type,url,examinedProgram,enabledFlags,disabledFlags)
						# Keep a list for caching's sake
						programList.append(update)
						# Only yield when under the limit, but continue the loop for caching
						if not self.skip(program,version,revision) and (not limit or yieldCount < limit):
							yieldCount+=1
							if limit and yieldCount>=limit: progressMeter.clear()
							yield update
							progressMeter.inc2() # Increment yielded update bar
		self.saveCache(programList, considered, True)
		progressMeter.clear()
	
	def installUpdate(self, update):
		program,version,revision,type,url,intBy,enabledFlags,disabledFlags = update
		if type == 'recipe':
			if os.system("Compile -G -U -D -b %s"%(url)):
				raise InstallationError(program)
		elif type == 'official_package':
			if os.system("InstallPackage -k -U -s keep -b -D -u keep %s"%(url)):
				raise InstallationError(program)
		else:
			raise InstallationError(None)
	
	def skip(self, program,version,revision):
		"""Boolean: whether this program should be skipped, as specified in the skipList. Wildcard entries are included, so skipping "KDE" will also skip anything named KDE-*."""
		if program in self.skipSet: return True
		# Skip e.g. KDE-* with -x KDE
		spl = program.split('-')
		if len(spl)>1 and spl[0] in self.skipSet: return True
		return False
	
	
	def cacheFile(self):
		"""Return the filename for cached update data, given the current examineSet and mode."""
		cacheDir = os.environ.get('HOME') + '/.Settings/freshen_cache'
		if not os.path.exists(cacheDir):
			os.makedirs(cacheDir)
		return "%s/%s-%u"%(cacheDir, self.mode, self.cacheDataID)
		
	
	def saveCache(self, programList, considered, listComplete):
		"""Save the update data to cache, and whether this data is complete or not. Also delete expired cache files."""
		try:
			f = open(self.cacheFile(), 'w')
			pickle.dump(self._cacheDataFormatVersion, f, protocol = pickle.HIGHEST_PROTOCOL)
			pickle.dump(programList, f, protocol = pickle.HIGHEST_PROTOCOL)
			pickle.dump(considered, f, protocol = pickle.HIGHEST_PROTOCOL)
			pickle.dump(listComplete, f, protocol = pickle.HIGHEST_PROTOCOL)
		except Exception:
			exc = sys.exc_info()
			raise CacheWarning("Unable to save update data cache. ~/.Settings/freshen_cache or its\ncontents may be non-writable (%s.%s: %s)"%(exc[0].__module__, exc[0].__name__, exc[1]))
		finally:
			if f: f.close()
		directory = os.environ.get('HOME') + '/.Settings/freshen_cache/'
		# Delete expired cache files
		for fn in os.listdir(directory):
			if time.time()-os.path.getmtime(directory+'/'+fn)>1800:
				os.unlink(directory+'/'+fn)
		
	
	def loadCache(self):
		"""Load data from the cache file, if available. If data is expired, does not exist, caching is disabled, the cache data format is outdated, or there is some other error, returns an empty dataset. Result is a tuple (progList (list), considered (set), listComplete (boolean))."""
		cacheFile = self.cacheFile()
		if self.forceCache or not self.noCache and os.path.exists(cacheFile) and os.path.exists(cacheFile) and time.time()-os.path.getmtime(cacheFile)<1800:
			self.callback('loading_updates_from_cache')
			try:
				f = open(cacheFile, 'r')
				format = pickle.load(f)
				if format != self._cacheDataFormatVersion:
					return ([], set(), False)
				progList = pickle.load(f)
				considered = pickle.load(f)
				listComplete = pickle.load(f)
			except:
				return ([], set(), False)
			finally:
				f.close()
			return (progList, considered, listComplete)
		return ([], set(), False)
	
	
	def fetchAvailables(self, forceNoCache=False):
		"""Load the available package database, from cache when available or using GetAvailable otherwise."""
		global global_available_packages_cache
		cacheFile = os.environ.get('HOME') + '/.Settings/freshen_cache/availables.cache'
		if global_available_packages_cache: return
		elif not forceNoCache and not self.noCache and os.path.exists(cacheFile) and (self.forceCache or time.time()-os.path.getmtime(cacheFile)<1800):
			try:
				f = open(cacheFile, 'r')
				global_available_packages_cache = pickle.load(f)
			except:
				self.fetchAvailables(forceNoCache=True)
			finally:
				f.close()
		else:
			consoleProgressHook.endString = '\015'
			global_available_packages_cache = 	GetAvailable(types=['installed','local_package','official_package', 'recipe', 'contrib_package', 'tracked'], hook=consoleProgressHook)
			f = open(cacheFile, 'w')
			pickle.dump(global_available_packages_cache, f, protocol = pickle.HIGHEST_PROTOCOL)
			f.close()
	
	
	def clearCache(self):
		"""Clear the current cache files."""
		cacheFile = self.cacheFile()
		for cacheFile in (self.cacheFile(), os.environ.get('HOME')+'/.Settings/freshen_cache/availables.cache'):
			if os.path.exists(cacheFile):
				os.unlink(cacheFile)
	
	def callback(self, callback, *args):
		"""Call back into the interface to display information asynchronously."""
		if callback in self.interfaceCallbacks:
			self.interfaceCallbacks[callback](*args)

class DummyProgressMeter(object):
	"""Filler class used when no progressMeter is passed."""
	value = 0
	value2 = 0
	def __init__(self, max1=None, max2=None):
		pass
	def inc(self, n=1):
		self.value+=n
	def inc2(self, n=1):
		self.value2+=n
	def clear(self):
		pass

class InstallationError(StandardError):
	program = None
	def __init__(self, program):
		self.program = program

class CacheWarning(UserWarning):
	pass
