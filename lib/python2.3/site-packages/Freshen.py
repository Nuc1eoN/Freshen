from GetAvailable import GetAvailable
from CheckDependencies import *
import pickle

class Freshen(object):
	_installedProgramsCache = {}
	_currentVersionCache = {}
	_latestCache = None
	_cacheDataFormatVersion = 1
	version = {'major': 3, 'minor': 0, 'revision': 0, 'prerelease': 'alpha'}
	
	mode = 'updating'
	noCache = False
	forceCache = False
	limit = None
	skipSet = frozenset()
	examineSet = frozenset()
	cacheDataID = 0
	progString = 'all'

	def __init__(self, mode='updating', examineSet=None, limit=None, skipSet=None, noCache=False, forceCache=False):
		if examineSet:
			# examineSet is an iterable, so convert it into a set.
			self.examineSet = frozenset(examineSet)
			self.progString = ', '.join(examineSet)
		elif 'all' == mode:
			# In the thorough mode, we examine every program regardless of state
			self.examineSet = frozenset(self.installedPrograms())
		else:
			# The rest of the time, only examine programs with updates available
			self.examineSet = frozenset(prog for prog in self.installedPrograms() if self.updateAvailable(prog))
		self.cacheDataID = hash(self.examineSet)
		
		self.mode = mode
		self.limit = limit
		if skipSet:
			self.skipSet = frozenset(skipSet)
		self.noCache = noCache
		self.forceCache = forceCache

	def installedPrograms(self):
		if self._installedProgramsCache:
			return self._installedProgramsCache
		else:
			global global_available_packages_cache
			if not global_available_packages_cache: self.fetchAvailables()
			installed = global_available_packages_cache['installed']['programs']
			# Generator: tuple (program, versionlist)
			# List comprehension: string "version-revision" installed versions of program
			self._installedProgramsCache = KeyInsensitiveDict((prog, [v+'-'+r for v in installed[prog] for r in installed[prog][v]]) for prog in installed)
			return self._installedProgramsCache
			
	
	def latestInstalled(self, program):
		if not self._currentVersionCache:
			self._currentVersionCache = KeyInsensitiveDict()
		if program in self._currentVersionCache:
			return self._currentVersionCache[program]
		else:
			if not self._installedProgramsCache: installedPrograms()
			if program in self._installedProgramsCache:
				self._currentVersionCache[program] = GuessLatest(self._installedProgramsCache[program])
			else:
				self._currentVersionCache[program] = None
			return self._currentVersionCache[program]
	
	
	def latestAvailable(self, program):
		global global_available_packages_cache
		if not global_available_packages_cache: self.fetchAvailables()
		if not self._latestCache:
			self._latestCache = KeyInsensitiveDict()
		if program in self._latestCache:
			return self._latestCache[program]
		latest = None
		recipes = global_available_packages_cache['recipe']['programs']
		if program in recipes:
			lver = GuessLatest(recipes[program])
			lrev = GuessLatest(recipes[program][lver])
			latest = Join_Version_Revision(lver, lrev)
		packages = global_available_packages_cache['official_package']['programs']
		if program in packages:
			lver = GuessLatest(packages[program])
			lrev = GuessLatest(packages[program][lver])
			if not latest: latest = Join_Version_Revision(lver, lrev)
			else: latest = GuessLatest((latest, Join_Version_Revision(lver, lrev)))
		return latest
	
	
	def updateAvailable(self, program):
		latestInstalled = self.latestInstalled(program)
		latestAvailable = self.latestAvailable(program)
		if not latestInstalled: return True
		if not latestAvailable: return False
		return (GuessLatest((latestInstalled, latestAvailable)) != latestInstalled)
		
	
	def updates(self, progressMeter=None):
		types = ['official_package', 'recipe']
		if not progressMeter:
			progressMeter = DummyProgressMeter()
		toExamine,mode,skipSet = self.examineSet, self.mode, self.skipSet
		yieldCount = 0
		if self.limit: limit = int(self.limit)
		else: limit = None
		# Load from cache, and yield any programs in there up to the limit
		programList,considered,listComplete = self.loadCache()
		
		for program,version,revision,type,url,intBy in programList:
			if yieldCount == limit: return # Satisfied request from cache, so terminate.
			if not self.skip(program, version, revision):
				yieldCount+=1
				progressMeter.inc2()
				yield (program,version,revision,type,url,intBy)
		if listComplete:
			progressMeter.clear()
			return
		for examinedProgram in toExamine:
			progressMeter.inc() # Increment examined program bar
			if examinedProgram in considered: continue
			if limit and progressMeter.value2 >= limit:
				self.saveCache(programList, considered, False)
				raise StopIteration
			if self.skip(examinedProgram, None, None): continue
			# Process actual results from here
			orderedRules,orderedMatches = CheckDependencies(examinedProgram, acceptable_types=types, mode=mode, recursive=True)
			for program,version,revision,type,url in (upd for upd in orderedMatches if upd[0] not in considered):
				considered.add(program)
				if type != 'installed' and type is not None:
					ver = Join_Version_Revision(version, revision)
					insVer = self.latestInstalled(program)
					if not insVer or (insVer != ver and GuessLatest((ver, insVer)) == ver):
						update = (program,version,revision,type,url,examinedProgram)
						programList.append(update) # Keep a list for caching's sake
						# Only yield when under the limit, but continue the loop for caching
						if not self.skip(program,version,revision) and (not limit or yieldCount < limit):
							yieldCount+=1
							if limit and yieldCount>=limit: progressMeter.clear()
							yield update
							progressMeter.inc2() # Increment yielded update bar
		self.saveCache(programList, considered, True)
		progressMeter.clear()
	
	
	def skip(self, program,version,revision):
		if program in self.skipSet: return True
		# Skip e.g. KDE-* with -x KDE
		spl = program.split('-')
		if len(spl)>1 and spl[0] in self.skipSet: return True
		return False
	
	
	def cacheFile(self):
		cacheDir = os.environ.get('HOME') + '/.Settings/freshen_cache'
		if not os.path.exists(cacheDir):
			os.makedirs(cacheDir)
		return "%s/%s-%u"%(cacheDir, self.mode, self.cacheDataID)
		
	
	def saveCache(self, programList, considered, listComplete):
		f = open(self.cacheFile(), 'w')
		pickle.dump(self._cacheDataFormatVersion, f, protocol = pickle.HIGHEST_PROTOCOL)
		pickle.dump(programList, f, protocol = pickle.HIGHEST_PROTOCOL)
		pickle.dump(considered, f, protocol = pickle.HIGHEST_PROTOCOL)
		pickle.dump(listComplete, f, protocol = pickle.HIGHEST_PROTOCOL)
		f.close()
		directory = os.environ.get('HOME') + '/.Settings/freshen_cache/'
		# Delete expired cache files
		for fn in os.listdir(directory):
			if time.time()-os.path.getmtime(directory+'/'+fn)>1800:
				os.unlink(directory+'/'+fn)
		
	
	def loadCache(self):
		cacheFile = self.cacheFile()
		if self.forceCache or not self.noCache and os.path.exists(cacheFile) and os.path.exists(cacheFile) and time.time()-os.path.getmtime(cacheFile)<1800:
			Log_Normal("Loading updates list from cache... (use -C to disable)", 'Freshen')
			f = open(cacheFile, 'r')
			format = pickle.load(f)
			if format != self._cacheDataFormatVersion:
				return ([], set(), False)
			progList = pickle.load(f)
			considered = pickle.load(f)
			listComplete = pickle.load(f)
			f.close()
			return (progList, considered, listComplete)
		return ([], set(), False)
	
	
	def fetchAvailables(self, forceNoCache=False):
		global global_available_packages_cache
		cacheFile = os.environ.get('HOME') + '/.Settings/freshen_cache/availables.cache'
		if global_available_packages_cache: return
		elif not forceNoCache and not self.noCache and os.path.exists(cacheFile) and (self.forceCache or time.time()-os.path.getmtime(cacheFile)<1800):
			f = open(cacheFile, 'r')
			global_available_packages_cache = pickle.load(f)
			f.close()
		else:
			consoleProgressHook.endString = '\015'
			global_available_packages_cache = 	GetAvailable(types=['installed','local_package','official_package', 'recipe', 'contrib_package', 'tracked'], hook=consoleProgressHook)
			f = open(cacheFile, 'w')
			pickle.dump(global_available_packages_cache, f, protocol = pickle.HIGHEST_PROTOCOL)
			f.close()
	
	
	def clearCache(self):
		cacheFile = self.cacheFile()
		for cacheFile in (self.cacheFile(), os.environ.get('HOME')+'/.Settings/freshen_cache/availables.cache'):
			if os.path.exists(cacheFile):
				os.unlink(cacheFile)

class DummyProgressMeter(object):
	def __init__(self, max1=None, max2=None):
		pass
	def inc(self, n=1):
		pass
	def inc2(self, n=1):
		pass
	def clear(self):
		pass
