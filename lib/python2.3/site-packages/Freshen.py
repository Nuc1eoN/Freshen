# Copyright (C) 2007-2008 Michael Homer <=mwh>
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from GetAvailable import GetAvailable
from CheckDependencies import *
from UseFlags import UseFlags, potentialFlags
import pickle

version = {'major': 3, 'minor': 0, 'revision': 2, 'prerelease': ''}


class Freshen(object):
	_installedProgramsCache = {}
	_currentVersionCache = {}
	_latestCache = None
	_cacheDataFormatVersion = 2
	
	mode = 'updating'
	noCache = False
	forceCache = False
	skipSet = frozenset()
	examineSet = frozenset()
	cacheDataID = 0
	progString = 'all'
	types = ['official_package', 'recipe']

	def __init__(self, mode='updating', examineSet=None, skipSet=None,
		         noCache=False, forceCache=False, types=None):
		if examineSet:
			# examineSet is an iterable, so convert it into a set.
			self.examineSet = frozenset(examineSet)
			self.progString = ', '.join(examineSet)
		elif 'all' == mode:
			# In the thorough mode, examine every program regardless of state
			self.examineSet = frozenset(self.installedPrograms())
		else:
			# The rest of the time, only examine those with updates available
			self.examineSet = frozenset(prog for prog in
			                            self.installedPrograms() if
										self.updateAvailable(prog))
		self.examineSet -= skipSet
		if types: self.types = types
		self.cacheDataID = hash((self.examineSet, tuple(self.types)))
		
		self.mode = mode
		if skipSet:
			self.skipSet = frozenset(skipSet)
		self.noCache = noCache
		self.forceCache = forceCache
		self.updateCount = 0

	def installedPrograms(self):
		"""Returns a KeyInsensitiveDict of program=>[version-revisions]"""
		if self._installedProgramsCache:
			return self._installedProgramsCache
		else:
			global global_available_packages_cache
			if not global_available_packages_cache: self.fetchAvailables()
			installed = global_available_packages_cache \
			             ['installed']['programs']
 			# Generator: tuple (program, versionlist)
			# List comprehension: string "version-revision" installed
			# versions of program
			self._installedProgramsCache = KeyInsensitiveDict((prog,
				[v+'-'+r for v in installed[prog] for r in installed[prog][v]])
				for prog in installed)
			return self._installedProgramsCache
			

	def latestInstalled(self, program):
		"""Return the latest installed version-revision of program."""
		if not self._currentVersionCache:
			self._currentVersionCache = KeyInsensitiveDict()
		if program in self._currentVersionCache:
			return self._currentVersionCache[program]
		else:
			if not self._installedProgramsCache: self.installedPrograms()
			if program in self._installedProgramsCache:
				self._currentVersionCache[program] = \
					GuessLatest(self._installedProgramsCache[program])
			else:
				self._currentVersionCache[program] = None
			return self._currentVersionCache[program]

	def latestAvailable(self, program):
		"""Return the latest available version of program (cached)."""
		global global_available_packages_cache
		if not global_available_packages_cache: self.fetchAvailables()
		if not self._latestCache:
			self._latestCache = KeyInsensitiveDict()
		if program in self._latestCache:
			return self._latestCache[program]
		latest = None
		for type in self.types:
			typedata = global_available_packages_cache[type]['programs']
			if program in typedata:
				lver = GuessLatest(typedata[program])
				lrev = GuessLatest(typedata[program][lver])
				thisver = Join_Version_Revision(lver, lrev)
				if not latest: latest = thisver
				else: latest = GuessLatest((thisver, latest))
		return latest

	def updateAvailable(self, program):
		"""Boolean function: whether there is a newer version of program
		   available than installed."""
		latestInstalled = self.latestInstalled(program)
		latestAvailable = self.latestAvailable(program)
		if not latestInstalled: return True
		if not latestAvailable: return False
		return (
			GuessLatest((latestInstalled, latestAvailable))
			!= latestInstalled)
		

	def updates(self, onExamine=None, last=False, saveCache=True):
		"""Generator of tuples of available updates, in dependency-
		resolved order.
		
		Each tuple is (program, version, revision, type, url,
		introducedBy, enabledFlags, disabledFlags)
		
		introducedBy is ONE program that has this program as a
		dependency, and is only useful when the program is not already
		installed.
		
		enabledFlags and disabledFlags are the appropriate sets of
		flags this program mentions it may use in its Dependencies
		file. They are only non-empty for recipes, as the flags are
		unavailable and not useful for packages.
		"""
		global global_available_packages_cache
		toExamine,mode,skipSet = self.examineSet, self.mode, self.skipSet
		yieldCount = 0
		# Load from cache, and yield any programs from that
		programList,considered,listComplete = self.loadCache(last=last)
		if listComplete:
			self.updateCount = len(programList)
		for program, version, revision, type, url, intBy, enabledFlags, \
			 disabledFlags, activeFlags in programList:
			# Check if this should be included, and yield it if so.
			if not self.skip(program, version, revision):
				yield (program, version, revision, type, url, intBy,
				       enabledFlags, disabledFlags, activeFlags)
		# No more updates are available, so don't bother trying
		if listComplete: return
		
		try:
			# Now that the cache is exhausted, go through the programs we need
			# to examine.
			for examinedProgram in toExamine:
				# Call the hook if given
				if onExamine: onExamine()
				# Don't consider programs twice.
				# They could have been covered here or from the cache.
				if examinedProgram in considered: continue
				
				if self.skip(examinedProgram, None, None): continue
				
				if self.mode == 'unordered':
					packages = FindPackage(examinedProgram, types=self.types,
					               availables=global_available_packages_cache,
				                   accessWeb=False)
					newest = packages[0]
					if 'recipe' == newest[3]:
						enabledFlags = UseFlags(newest[4])
						# Calculate the disabled flags from the potentials
						# and enableds
						disabledFlags = (potentialFlags(newest[4])
						                 - enabledFlags)
						newest = (newest[0], newest[1], newest[2], newest[3],
						          newest[4], newest[0], enabledFlags,
						          disabledFlags)
					else:
						newest = (newest[0], newest[1], newest[2], newest[3],
						          newest[4], newest[0], frozenset(),
								  frozenset())
					programList.append(newest)
					yield newest
					continue
					
				# Process actual results from here
				orderedRules,orderedMatches = CheckDependencies(
					examinedProgram, acceptable_types=self.types,
					mode=mode, recursive=True)
				thisProgramUpdates = []
				frz = frozenset()
				# Loop through the update data for dependencies that have not
				# been considered already
				for program,version,revision,type,url,activeflags in (
					upd+(rule.get('activeflags',frz),) for upd,rule in zip(
						orderedMatches,orderedRules)
						if upd[0] not in considered):
					considered.add(program)
					enabledFlags = frozenset()
					disabledFlags = frozenset()
					# Installed dependencies may be listed too in some modes,
					# but skip them.
					if type != 'installed' and type is not None:
						ver = Join_Version_Revision(version, revision)
						insVer = self.latestInstalled(program)
						# Only updated or wholly new programs should
						# be included. However, note that in some cases
						# older versions of programs will be required.
						if not insVer or \
							ver not in self.installedPrograms()[program]:
							if 'recipe' == type:
								# Flags are only really meaningful (and
								# available) for recipes
								enabledFlags = UseFlags(url)
								# Calculate the disabled flags from the
								# potentials and enableds
								disabledFlags = (potentialFlags(url)
								                 - enabledFlags)
							
							update = (program,version,revision,type,url,
							          examinedProgram,enabledFlags,
									  disabledFlags,activeflags)
							# Keep a list of updates for this program, that
							# will be added to the global list and yielded
							# later on.
							if not self.skip(program,version,revision):
								thisProgramUpdates.append(update)
				# Save updates into the cache now, then yield them: it's
				# possible the loop will terminate before they're done.
				programList.extend(thisProgramUpdates)
				for update in thisProgramUpdates:
					yield update
			listComplete = True
		finally:
			if saveCache:
				self.saveCache(programList, considered, listComplete)

	def installUpdate(self, update):
		(program, version, revision, type, url, intBy, enabledFlags,
		 disabledFlags, activeFlags) = update
		if type == 'recipe':
			if os.system("Compile -G -U -D -b %s" % (url)):
				raise InstallationError(program)
		elif type == 'official_package' or type == 'contrib_package':
			if os.system("InstallPackage -s keep -k -U -s keep -b -D "
				         "--unmanaged=install %s" % (url)):
				raise InstallationError(program)
		else:
			raise InstallationError(None)
	
	def skip(self, program,version,revision):
		"""Boolean: whether this program should be skipped
		
		   Wildcard entries are included, so skipping "KDE" will also
		   skip anything named KDE-*.
		   """
		if program in self.skipSet: return True
		# Skip e.g. KDE-* with -x KDE
		spl = program.split('-')
		if len(spl) > 1 and spl[0] in self.skipSet: return True
		return False
	
	
	def cacheFile(self, file=None):
		"""Return the filename for cached update data, given the current
		   examineSet and mode."""
		cacheDir = os.environ.get('HOME') + '/.Settings/freshen_cache'
		if not os.path.exists(cacheDir):
			os.makedirs(cacheDir)
		if file:
			return "%s/%s" % (cacheDir, file)
		return "%s/%s-%u" % (cacheDir, self.mode, self.cacheDataID)
		

	def saveCache(self, programList, considered, listComplete):
		"""Save the update data to cache, and whether this data is complete.
		   Also delete expired cache files.
		   """
		try:
			f = open(self.cacheFile(), 'w')
			pickle.dump(self._cacheDataFormatVersion, f,
			            protocol = pickle.HIGHEST_PROTOCOL)
			pickle.dump(programList, f, protocol = pickle.HIGHEST_PROTOCOL)
			pickle.dump(considered, f, protocol = pickle.HIGHEST_PROTOCOL)
			pickle.dump(listComplete, f, protocol = pickle.HIGHEST_PROTOCOL)
		except Exception:
			exc = sys.exc_info()
			raise CacheWarning("Unable to save update data cache. "
		                       "~/.Settings/freshen_cache or its\ncontents may"
							   "be non-writable (%s.%s: %s)" %
							   (exc[0].__module__, exc[0].__name__, exc[1]))
		finally:
			if f:
				f.close()
				lastCache = self.cacheFile('lastcache')
				if os.path.exists(lastCache):
					os.unlink(lastCache)
				os.link(self.cacheFile(), lastCache)
		directory = os.environ.get('HOME') + '/.Settings/freshen_cache/'
		# Delete expired cache files
		for fn in os.listdir(directory):
			if time.time() - os.path.getmtime(directory + '/' + fn) > 1800:
				os.unlink(directory + '/' + fn)
		

	def loadCache(self, last=False):
		"""Load data from the cache file, if available.
		
		   If data is expired, does not exist, caching is disabled,
		   the cache data format is outdated, or there is some other
		   error, returns an empty dataset. Result is a tuple
		   (progList (list), considered (set), listComplete (boolean)).
		   """
		cacheFile = self.cacheFile()
		if last:
			cacheFile = self.cacheFile('lastcache')
		if (self.forceCache or not self.noCache and
			os.path.exists(cacheFile) and os.path.exists(cacheFile) and
			time.time() - os.path.getmtime(cacheFile) < 1800):
			try:
				f = open(cacheFile, 'r')
				format = pickle.load(f)
				if format != self._cacheDataFormatVersion:
					return ([], set(), False)
				progList = pickle.load(f)
				considered = pickle.load(f)
				listComplete = pickle.load(f)
			except:
				return ([], set(), False)
			finally:
				f.close()
			return (progList, considered, listComplete)
		return ([], set(), False)

	def fetchAvailables(self, forceNoCache=False):
		"""Load the available package database.
		   
		   Use cache when available or GetAvailable otherwise.
		   """
		global global_available_packages_cache
		cacheFile = self.cacheFile('availables.cache')
		if global_available_packages_cache: return
		elif (not forceNoCache and not self.noCache and
			  os.path.exists(cacheFile) and (self.forceCache or
			  time.time() - os.path.getmtime(cacheFile) < 1800)):
			try:
				f = open(cacheFile, 'r')
				global_available_packages_cache = pickle.load(f)
			except:
				self.fetchAvailables(forceNoCache=True)
			finally:
				f.close()
		else:
			consoleProgressHook.endString = '\015'
			global_available_packages_cache = 	GetAvailable(
				types=['installed', 'local_package', 'official_package',
				'recipe', 'contrib_package', 'tracked'],
				hook=consoleProgressHook)
			try:
				f = open(cacheFile, 'w')
				pickle.dump(global_available_packages_cache, f,
				            protocol = pickle.HIGHEST_PROTOCOL)
			except Exception:
				exc = sys.exc_info()
				raise CacheWarning("Unable to save program data cache."
			                       "~/.Settings/freshen_cache or its\ncontents"
								   "may be non-writable (%s.%s: %s)" % 
								   (exc[0].__module__, exc[0].__name__, exc[1]))
			finally:
				if f: f.close()

	def clearCache(self):
		"""Clear the current cache files."""
		cacheFile = self.cacheFile()
		for cacheFile in (self.cacheFile(),
			              os.environ.get('HOME') + 
			              '/.Settings/freshen_cache/availables.cache'):
			if os.path.exists(cacheFile):
				os.unlink(cacheFile)

class InstallationError(Exception):
	program = None
	def __init__(self, program):
		self.program = program

class CacheWarning(UserWarning):
	pass
